## 自己动手写一个CPU



### 参考说明

***

1. "自己动手写CPU/自己动手写CPU光盘资源.rar"

2. **[ MIPS-CPU-implementation](https://github.com/Hanmengnan/MIPS-CPU-implementation)**

3. 硬件综合设计资料_full_v0.1.zip

4. [cqu设计要求以及文档地址gitee](https://gitee.com/yuanfuyan/CO-lab-material-CQU)

   

### 数据通路图

***

**五级流水**

* ![image-20201229010821096](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201229010821096.png)

  

**只实现ori的五级流水通路**

* ![image-20201229010720490](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201229010720490.png)

**原始五级流水**

* <img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201229010855602.png" alt="image-20201229010855602"  />

  

**为实现数据前推而对OpenMIPS 结构所做的修改**

* ![image-20201229192342526](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201229192342526.png)

**添加了Hilo寄存器之后部分修改的数据通路**

* ![image-20201230094911277](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201230094911277.png)

**流水线暂停——增加控制模块**

* ![image-20201231234443452](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201231234443452.png)
* ![image-20201231234715735](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201231234715735.png)
* 请求只能从ID或EX阶段发出，每当要暂停的时候，pc都要暂停。

***实现累乘加指令***

* ![image-20210101015246423](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210101015246423.png)
* 这一部分暂不增加这样的接口

**实现除法指令修改的部分数据通路**

* ![image-20210101021007615](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210101021007615.png)

* 接口说明

  * ex.v![image-20210101022626252](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210101022626252.png)

    

  * div.v![image-20210101022749610](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210101022749610.png)


**完成了算术运算指令的数据通路图**

* ![image-20210101200911408](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210101200911408.png)

**分支跳转指令对数据流图以及数据通路图的修改**

* ![image-20210102011335498](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210102011335498.png)
* 数据流图![image-20210102011358540](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210102011358540.png)
* 数据通路图![image-20210102011945105](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210102011945105.png)



**加载存储指令**

* 修改的部分![image-20210102210451409](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210102210451409.png)
  * 对于mem模块所加入的mem_sel_o的说明：
  * ![image-20210103012514201](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210103012514201.png)
* 解决load相关而增加的接口
  * ![image-20210103103249802](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210103103249802.png)



**添加了mtco与mfc0指令后的修改**

* 数据流图![image-20210104172318009](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210104172318009.png)
* 系统结构
  * ![image-20210104172437711](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210104172437711.png)
  * 其中int_i是openmips的输入。对应openmips的增加接口说明。
    * ![image-20210104173540566](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210104173540566.png)

**添加了异常处理后的修改**

* 数据流图![image-20210105002450363](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210105002450363.png)
* 系统结构的修改![image-20210105002607816](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210105002607816.png)
  * 注：stall是用来数据前推的，flush是用来处理异常发生的





### 确定指令的过程

***

**逻辑，移位指令**

* ![image-20201229211928550](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201229211928550.png)



**数据移动指令**

* ![image-20201230094724520](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201230094724520.png)

**算术运算指令**

* 缺少div与div指令的确定
  * ![image-20201231150539826](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201231150539826.png)
  
  

**数据加载指令**

* ![image-20210102210907985](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210102210907985.png)



### 指令实现

***

下面所有实现的指令，其意义参考了《MIPS指令系统规范_v1.01.pdf（系统能力培养大赛）》，程序框架以及实现方法参考了《自己动手写CPU》.(雷思磊).pdf》，如果是具体实现的指令方式参考了别的开源代码的话，会在每一类指令的开头给出参考说明。

**逻辑运算指令**

* ![image-20201229231455396](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201229231455396.png)
* 其中ori指令这里注明有误，正确应为
  * ![image-20201229231937325](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201229231937325.png)
* 如果是I性逻辑运算指令，这里的扩展就都是o扩展。
* LUI指令
  * ![image-20201229233352137](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201229233352137.png)
* LUI的译码过程![image-20201230000959252](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201230000959252.png)

**进行测试**

* 测试文件"my_cpu\source\funcTest_independent\LogicInstTest\logic.coe"
* 指令![image-20201230204527339](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201230204527339.png)
* 测试结果
  * ![image-20201230204728831](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201230204728831.png)
  * ![image-20201230210702343](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201230210702343.png)
* 结果正确

**移位指令**

* 参考说明：
  
1. mthi指令与mtlo指令的实现以及sll,srl,sra的准确译码参考《自己动手写CPU》.(雷思磊).pdf》的方法

* ![image-20201229231354263](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201229231354263.png)

* 移位指令的详细解释

  * ![image-20201229234237170](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201229234237170.png)
  * ![image-20201229234404657](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201229234404657.png)
    * 最后面是l（logic）代表逻辑，最后面是a（arithmetic）代表算数

* 对于移位指令，有两个地方碰到了一些问题。

  * 通过rs来移位的是rs的低五位，即rs[4:0]
  * sra指令的算数右移可以通过>>>来实现，但是要通过$signed来强制转换。

* 为了通过书中的测试，添加sync与pref指令

  * ![image-20201230144249390](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201230144249390.png)
  * 但是这两条指令相当于没有指令，在这里书中在ex.v中也没有处理。

* 进行测试，测试文件"my_cpu\source\funcTest_independent\ShiftInstTest\shift.coe"

* 指令

  * ![image-20201230215613579](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201230215613579.png)

    

* 测试结果

  * ![image-20201230215503867](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201230215503867.png)

* 结果正确

**数据移动指令**

* 参考说明：
  1. mthi指令与mtlo指令的实现参考《自己动手写CPU》.(雷思磊).pdf》的方法
  2. Hilo寄存器的实现也参考了《自己动手写CPU》.(雷思磊).pdf》

* ![image-20201230023350085](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201230023350085.png)

* mfhi指令

  * ![image-20201230024353299](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201230024353299.png)

* mflo指令

  * ![image-20201230024140732](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201230024140732.png)

* mthi指令

  * ![image-20201230024315118](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201230024315118.png)

    

* mtlo指令

  * ![image-20201230024440697](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201230024440697.png)

    

* 这四个指令需要特殊寄存器HI，LO。

* 避免数据移动指令带来的数据相关。
  * ![image-20201230024920941](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201230024920941.png)
  * 在访存与回写阶段增加两条旁路
* 为了通过书中的测试，额外添加movn，movz指令，![image-20201230142835424](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201230142835424.png)
  
  * ![image-20201230142912401](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201230142912401.png)

**进行测试**

* 测试文件"my_cpu\source\funcTest_independent\ShiftInstTest\shift.coe"

* 指令
  * ![image-20201230215959745](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201230215959745.png)
* 测试结果
  * ![image-20201230233041081](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201230233041081.png)
  * ![image-20201230234708052](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201230234708052.png)
  * 时序图说明，这里着重看寄存器$4，hi寄存器和lo寄存器。其中32个寄存器的值都是写回阶段完成之后的值，而hi寄存器和lo寄存器，对应的结果都是访存阶段结束的值，所以这也就是为什么最后两条指令中lo寄存器的值与寄存器\$4的值中间会隔开一个周期，尽管他们是紧邻的两个指令。
* 测试成功

**算术运算指令**

* 参考说明
  1. 可能产生溢出的指令add,addi,sub的溢出出现情况，slt,div,divu指令的实现参考《自己动手写CPU》.(雷思磊).pdf》的方法
  2. mult指令参考给的PPT“ISA讲解_2020.pptx”。

* ![image-20201230203024866](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201230203024866.png)

* ![image-20201231142210653](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201231142210653.png)

  

* 这里的扩展就都是有符号扩展。

* 四种加法指令，add,addu,addi,addiu，其中add和addi有可能发生溢出

  * ![image-20201231141408330](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201231141408330.png)

  

* 两种减法指令，sub, subu

* 两种乘法指令，mult,multu

  * ![image-20201231151010361](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201231151010361.png)

    

* 两种除法指令，div,divu，详细解释在《自己动手写cpu》p194

  * ![image-20210101020235567](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210101020235567.png)
  * ![image-20210101020338372](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210101020338372.png)
  * 这里的div和divu两条指令是完全参照《自己动手写cpu》这本书的，这里给出关于除法的一些状态。
  * ![image-20210101123955448](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210101123955448.png)
  * ![image-20210101124103020](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210101124103020.png)
  * 

* 四种置1指令，

  * ![image-20201231143207615](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201231143207615.png)

* 书中对于溢出处理情况的介绍

  * ![image-20201231185901727](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201231185901727.png)
  * 负数取补码之后，相当于是对转换为加法考虑

* slt指令的确定执行过程

  * ![image-20201231185942361](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201231185942361.png)


**进行测试**

* 测试文件"my_cpu\source\funcTest_independent\ArithmeticTest\arithmetic.coe"

* 测试数据

  * ```assembly
       .org 0x0
       .set noat
       .global _start
    _start:
    
       ######### add\addi\addiu\addu\sub\subu ##########
    
       ori  $1,$0,0x8000           # $1 = 0x8000
       sll  $1,$1,16               # $1 = 0x80000000
       ori  $1,$1,0x0010           # $1 = 0x80000010
    
       ori  $2,$0,0x8000           # $2 = 0x8000
       sll  $2,$2,16               # $2 = 0x80000000
       ori  $2,$2,0x0001           # $2 = 0x80000001
    
       ori  $3,$0,0x0000           # $3 = 0x00000000
       addu $3,$2,$1               ## $3 = 0x00000011
       ori  $3,$0,0x0000           # $3 = 0x00000000
    
    
       sub   $3,$1,$3              ## $3 = 0x80000010         
       subu  $3,$3,$2              ## $3 = 0xF
    
       addi $3,$3,2                ## $3 = 0x11
       ori  $3,$0,0x0000           # $3 = 0x00000000
       addiu $3,$3,0x8000          ## $3 = 0xffff8000
       
       sll $1,$1,1		
       add  $3,$2,$1               ## $3 = 0x80000021
    
       #########     slt\sltu\slti\sltiu     ##########
    
       or   $1,$0,0xffff           # $1 = 0xffff
       sll  $1,$1,16               # $1 = 0xffff0000
       slt  $2,$1,$0               ## $2 = 1
       sltu $2,$1,$0               ## $2 = 0
       slti $2,$1,0x8000           ## $2 = 1
       sltiu $2,$1,0x8000          ## $2 = 1
    
       #########          mult\multu          ##########
    
       ori  $1,$0,0xffff                  
       sll  $1,$1,16
       ori  $1,$1,0xfffb           # $1 = -5
       ori  $2,$0,6                # $2 = 6
      
       mult $1,$2                  ## hi = 0xffffffff
                                   ## lo = 0xffffffe2
    
       multu $1,$2                 ## hi = 0x5
                                   ## lo = 0xffffffe2
       nop
       nop
    
       ################# div\divu ####################
       ori  $2,$0,0xffff                  
       sll  $2,$2,16
       ori  $2,$2,0xfff1           ## $2 = -15
       ori  $3,$0,0x11             ## $3 = 17
    
       div $zero,$2,$3             ## hi = 0xfffffff1            
                                   ## lo = 0x0
       divu $zero,$2,$3            ## hi = 0x00000003
                                   ## lo = 0x0f0f0f0e
    
       div  $zero,$3,$2            ## hi = 2
                                   ## lo = 0xffffffff
    
    ```

* 测试结果

  * `add\addi\addiu\addu\sub\subu`
    * ![image-20210101192019719](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210101192019719.png)
    * ![image-20210101192237800](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210101192237800.png)
  * `slt\sltu\slti\sltiu`
    * ![image-20210101192432268](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210101192432268.png)
  *  `mult\multu `
    * ![image-20210101192643150](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210101192643150.png)
  * `div\divu`
    * ![image-20210101192900252](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210101192900252.png)

* 结果正确

**分支跳转指令**

* ![image-20210101201703574](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210101201703574.png)

* ![image-20210102010221060](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210102010221060.png)

  

* 涉及延迟槽
  
  * ![image-20210101202321174](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210101202321174.png)
  
* 跳转指令j,jal,jr,jalr
  * 带有r的说明为R型指令，要跳转的地址在rs中，带l的需要保存地址。
  * 需要保存地址的时候（l），R型（jalr），地址保存在rd中，J型(jal)，地址保存在31号通用寄存器中。
  * 保存的地址为将该分支对应延迟槽指令之后的指令的 PC 值。

* 分支指令，带有Z的就rs与Z比较，如BGEZ(branch greater or equal to zero).

* 所有的分支跳转指令在在转移到目标指令前都需要执行延迟槽的指令。这也就是为什么保存的地址为将该分支对应延迟槽指令之后的指令的 PC 值。

**进行测试**

**跳转指令**

* 测试数据1“"my_cpu\source\coe\J_BTest\Test1\branch.coe"”（自己动手写cpu）

  * ```assembly
       .org 0x0
       .set noat
       .set noreorder
       .set nomacro
       .global _start
    _start:
       ori  $1,$0,0x0001   # $1 = 0x1                
       j    0x20
       ori  $1,$0,0x0002   # $1 = 0x2
       ori  $1,$0,0x1111
       ori  $1,$0,0x1100
    
       .org 0x20
       ori  $1,$0,0x0003   # $1 = 0x3               
       jal  0x40
       div  $zero,$31,$1   # $31 = 0x2c, $1 = 0x3
                           # HI = 0x2, LO = 0xe 
       ori  $1,$0,0x0005   # r1 = 0x5
       ori  $1,$0,0x0006   # r1 = 0x6
       j    0x60
       nop
    
       .org 0x40
                   
       jalr $2,$31           
       or   $1,$2,$0        # $1 = 0x48
       ori  $1,$0,0x0009    # $1 = 0x9
       ori  $1,$0,0x000a    # $1 = 0xa
       j 0x80
       nop
    
       .org 0x60
       ori  $1,$0,0x0007    # $1 = 0x7                
       jr   $2           
       ori  $1,$0,0x0008    # $1 = 0x8
       ori  $1,$0,0x1111
       ori  $1,$0,0x1100
    
       .org 0x80
       nop
        
    _loop:
       j _loop
       nop
    
    ```

* 波形图

  * ![image-20210102172300966](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210102172300966.png)
  * ![image-20210102172420764](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210102172420764.png)
  * ![image-20210102172541481](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210102172541481.png)

* 测试正确

**分支指令**

* 测试数据测试数据1“"my_cpu\source\funcTest_independent\J_BTest\Test2\B.coe"”

* 测试指令

  * ```assembly
       .org 0x0
       .set noat
       .set noreorder
       .set nomacro
       .global _start
    _start:
       ori  $3,$0,0x8000
       sll  $3,16               # $3 = 0x80000000
       ori  $1,$0,0x0001        ## $1 = 0x1                
       b    sec1
       ori  $1,$0,0x0002        ## $1 = 0x2
    1:
       ori  $1,$0,0x1111
       ori  $1,$0,0x1100
    
       .org 0x20
    sec1:
       ori  $1,$0,0x0003        ## $1 = 0x3          
       bal  s2
       ori  $1,$0,0x1100
       ori  $1,$0,0x1111
       bne  $1,$0,s3
       nop
       ori  $1,$0,0x1100
       ori  $1,$0,0x1111
    
       .org 0x50   
    s2:
       ori  $1,$0,0x0004      ## $1 = 0x4
       beq  $3,$3,s3           
       or   $1,$31,$0         ## $1 = 0x2c
       ori  $1,$0,0x1111
       ori  $1,$0,0x1100
    2:
       ori  $1,$0,0x0007      ## $1 = 0x7
       ori  $1,$0,0x0008      ## $1 = 0x8
       bgtz $1,s4
       ori  $1,$0,0x0009      ## $1 = 0x9
       ori  $1,$0,0x1111
       ori  $1,$0,0x1100
    
       .org 0x80
    s3:
       ori  $1,$0,0x0005      ## $1 = 0x5            
       BGEZ $1,2b           
       ori  $1,$0,0x0006      ## $1 = 0x6
       ori  $1,$0,0x1111
       ori  $1,$0,0x1100
    
       .org 0x100
    s4:
       ori  $1,$0,0x000a      ## $1 = 0xa              
       BGEZAL $3,s3
       or   $1,$0,$31         ## $1 = 0x10c          
       ori  $1,$0,0x000b      ## $1 = 0xb
       ori  $1,$0,0x000c      ## $1 = 0xc
       ori  $1,$0,0x000d      ## $1 = 0xd
       ori  $1,$0,0x000e      ## $1 = 0xe
       bltz $3,s5
       ori  $1,$0,0x000f      ## $1 = 0xf
       ori  $1,$0,0x1100
    
    
       .org 0x130
    s5:
       ori  $1,$0,0x0010      ## $1 = 0x10            
       blez $1,2b           
       ori  $1,$0,0x0011      ## $1 = 0x11
       ori  $1,$0,0x0012      ## $1 = 0x12
       ori  $1,$0,0x0013      ## $1 = 0x13
       bltzal $3,s6
       or   $1,$0,$31         ## $1 = 0x14c
       ori  $1,$0,0x1100
    
    
       .org 0x160
    s6:
       ori $1,$0,0x0014       ## $1 = 0x14
       nop
       
       
        
    _loop:
       j _loop
       nop
    
    ```

* 波形图
  * ![image-20210102203319155](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210102203319155.png)
  * ![image-20210102203922223](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210102203922223.png)

* 测试正确



**访存指令**

* 参考说明， 对于访存指令LB, LH, SB, SH, SW 这些读取或者存储数据不满足一个字的指令参考了《自己动手写cpu》，特别的，对于load相关指令如果其读取的数据不满足一个字的话，读的时候全部读出，只需要写的时候进行处理即可。

* ![image-20210102205428342](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210102205428342.png)
* ![image-20210102205705907](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210102205705907.png)
* 指令说明
  1. LB，LH分别对应着读取字节，读取半字，所以就有LBU与LHU，将读取的这些数据按照无符号扩展。
  2. 这里所有的读取存储指令基地址都是rs中的值。

* 大端模式：低地址存数据高位

  * ![image-20210103004530109](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210103004530109.png)
  * ![image-20210103004645154](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210103004645154.png)
  * 这里再读取的时候要满足一个地址对齐要求。

* load相关问题

  * 比如如下指令：

    ```assembly 
    lw   $1, ox0($0);
    beq  $1, $2, Label;
    ```

  * load相关

  * ![image-20210103102115768](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210103102115768.png)

  * 解决方法：

    * 处于译码阶段的指令如果发现存在load相关问题，就在译码阶段发出暂停信号，让更新pc，取值，译码阶段都暂停，其他阶段继续。（需要在id阶段和执行阶段增加接口）

* 测试数据"my_cpu\source\funcTest_independent\J_BTest\Test2\B.coe"

  * ```assembly
       .org 0x0
       .set noat
       .set noreorder
       .set nomacro
       .global _start
    _start:
       ori  $3,$0,0xeeff
       sb   $3,0x3($0)       # [0x3] = 0xff
       srl  $3,$3,8
       sb   $3,0x2($0)       # [0x2] = 0xee
       ori  $3,$0,0xccdd
       sb   $3,0x1($0)       # [0x1] = 0xdd
       srl  $3,$3,8
       sb   $3,0x0($0)       # [0x0] = 0xcc
       lb   $1,0x3($0)       ## $1 = 0xffffffff
       lbu  $1,0x2($0)       ## $1 = 0x000000ee
       nop
    
       ori  $3,$0,0xaabb
       sh   $3,0x4($0)       # [0x4] = 0xaa, [0x5] = 0xbb
       lhu  $1,0x4($0)       ## $1 = 0x0000aabb
       lh   $1,0x4($0)       ## $1 = 0xffffaabb
     
       ori  $3,$0,0x8899
       sh   $3,0x6($0)       # [0x6] = 0x88, [0x7] = 0x99
       lh   $1,0x6($0)       ## $1 = 0xffff8899
       lhu  $1,0x6($0)       ## $1 = 0x00008899
    
       ori  $3,$0,0x4455
       sll  $3,$3,0x10
       ori  $3,$3,0x6677     
       sw   $3,0x8($0)       # [0x8] = 0x44, [0x9]= 0x55, [0xa]= 0x66, [0xb] = 0x77
       lw   $1,0x8($0)       ## $1 = 0x44556677
        
    _loop:
       j _loop
       nop
    
    ```

  * ![image-20210103150919483](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210103150919483.png)

* 波形图

  * ![image-20210103151311193](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210103151311193.png)
  * ![image-20210103151415411](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210103151415411.png)

* 结果正确



**内陷指令以及特权指令**

* 参考说明
  * cpo_reg.v的实现参考《自己动手写cpu》

* ![image-20210104165736229](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210104165736229.png)
* cp0协处理器起到系统控制的作用
  * 主要工作![image-20210104164916716](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210104164916716.png)
  * cp0协处理器中有一系列寄存器支持cp0的工作。
  * 需要mtc0和mfc0指令分别实现对cp0的存储与取值。
* mfc0与mtc0（对于openmips来说sel不用考虑，默认为0）
  * ![image-20210104172029281](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210104172029281.png)
* 精确异常
  * ![image-20210104234047663](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210104234047663.png)
* 实现精确异常的具体处理方法
  * 发生异常的指令（被异常打断的指令），该指令前面的所有指令都要被执行到流水线的最后一个阶段，也就是正常执行完成，但是该指令及该指令之后的指令都要被取消，就像从来没有执行过一样。同时要满足发生异常的指令与指令执行的顺序一致，如![image-20210104234436977](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210104234436977.png)
    * 这个图中，lw指令是在“di（无效指令）”指令之前的，但是lw被检测出异常慢于“di”。这个时候要采取办法先处理lw指令的异常——通过标记异常事件，然后当指令达到流水线的特定阶段（如访存）再处理。
* 异常处理过程
  * ![image-20210105001623330](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210105001623330.png)
  * ![image-20210105001736903](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210105001736903.png)
* 需要实现的异常
  * ![image-20210105002110269](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210105002110269.png)
  * 





### 52条指令测试结果

***

1. **`soft/func_part/obj_1/inst_rom.coe`测试**

   1. ![image-20210106223951766](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210106223951766.png)

      

2. **`soft/func_part/obj_2/inst_rom.coe`测试**
   1. ![image-20210104162330554](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210104162330554.png)
   2. ![image-20210104162400373](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210104162400373.png)
   3. 通过



**57条指令测试**

1. **`soft/func_part/obj_3/inst_rom.coe`测试**

   * ```assembly
     ==============================================================
     Test begin!
     ----[  14025 ns] Number 8'd01 Functional Test Point PASS!!!
     ----[  18675 ns] Number 8'd02 Functional Test Point PASS!!!
             [  22000 ns] Test is running, debug_wb_pc = 0xbfc00388
     ----[  23495 ns] Number 8'd03 Functional Test Point PASS!!!
     ----[  29155 ns] Number 8'd04 Functional Test Point PASS!!!
             [  32000 ns] Test is running, debug_wb_pc = 0xbfc00390
     ----[  34725 ns] Number 8'd05 Functional Test Point PASS!!!
     ----[  40385 ns] Number 8'd06 Functional Test Point PASS!!!
             [  42000 ns] Test is running, debug_wb_pc = 0xbfc00678
     ----[  46735 ns] Number 8'd07 Functional Test Point PASS!!!
             [  52000 ns] Test is running, debug_wb_pc = 0xbfc004c8
     ----[  53105 ns] Number 8'd08 Functional Test Point PASS!!!
     ----[  59455 ns] Number 8'd09 Functional Test Point PASS!!!
             [  62000 ns] Test is running, debug_wb_pc = 0xbfc0038c
     ----[  66095 ns] Number 8'd10 Functional Test Point PASS!!!
             [  72000 ns] Test is running, debug_wb_pc = 0xbfc049ec
     ----[  72735 ns] Number 8'd11 Functional Test Point PASS!!!
     ----[  79245 ns] Number 8'd12 Functional Test Point PASS!!!
             [  82000 ns] Test is running, debug_wb_pc = 0xbfc00a38
     ----[  85155 ns] Number 8'd13 Functional Test Point PASS!!!
             [  92000 ns] Test is running, debug_wb_pc = 0xbfc03ec4
     ----[  92925 ns] Number 8'd14 Functional Test Point PASS!!!
             [ 102000 ns] Test is running, debug_wb_pc = 0xbfc0068c
     ----[ 106645 ns] Number 8'd15 Functional Test Point PASS!!!
             [ 112000 ns] Test is running, debug_wb_pc = 0x00000000
     ----[ 120365 ns] Number 8'd16 Functional Test Point PASS!!!
             [ 122000 ns] Test is running, debug_wb_pc = 0xbfc00450
             [ 132000 ns] Test is running, debug_wb_pc = 0x00000000
     ----[ 134085 ns] Number 8'd17 Functional Test Point PASS!!!
             [ 142000 ns] Test is running, debug_wb_pc = 0x00000000
     ----[ 147805 ns] Number 8'd18 Functional Test Point PASS!!!
             [ 152000 ns] Test is running, debug_wb_pc = 0xbfc04564
     ----[ 161525 ns] Number 8'd19 Functional Test Point PASS!!!
             [ 162000 ns] Test is running, debug_wb_pc = 0xbfc0038c
             [ 172000 ns] Test is running, debug_wb_pc = 0x00000000
     ----[ 175245 ns] Number 8'd20 Functional Test Point PASS!!!
             [ 182000 ns] Test is running, debug_wb_pc = 0xbfc004bc
     ----[ 188975 ns] Number 8'd21 Functional Test Point PASS!!!
             [ 192000 ns] Test is running, debug_wb_pc = 0x00000000
             [ 202000 ns] Test is running, debug_wb_pc = 0xbfc04e5c
     ----[ 202715 ns] Number 8'd22 Functional Test Point PASS!!!
             [ 212000 ns] Test is running, debug_wb_pc = 0x00000000
     ----[ 216445 ns] Number 8'd23 Functional Test Point PASS!!!
             [ 222000 ns] Test is running, debug_wb_pc = 0xbfc00478
     ----[ 230175 ns] Number 8'd24 Functional Test Point PASS!!!
             [ 232000 ns] Test is running, debug_wb_pc = 0xbfc00698
             [ 242000 ns] Test is running, debug_wb_pc = 0xbfc00398
     ----[ 243905 ns] Number 8'd25 Functional Test Point PASS!!!
             [ 252000 ns] Test is running, debug_wb_pc = 0x00000000
     ----[ 257635 ns] Number 8'd26 Functional Test Point PASS!!!
     ==============================================================
     Test end!
     ----PASS!!!
     $finish called at time : 258285 ns : File "D:/practice_code/subject/hardware_design/soc_sram_func/testbench/mycpu_tb.v" Line 261
     
     ```

   * 通过。

2. **`soft/func_full/obj/inst_rom.coe`测试**

   * ```assembly
     ==============================================================
     Test begin!
     ----[  14025 ns] Number 8'd01 Functional Test Point PASS!!!
             [  22000 ns] Test is running, debug_wb_pc = 0xbfc5e4d4
             [  32000 ns] Test is running, debug_wb_pc = 0xbfc5f474
     ----[  40475 ns] Number 8'd02 Functional Test Point PASS!!!
             [  42000 ns] Test is running, debug_wb_pc = 0xbfc89440
     ----[  49355 ns] Number 8'd03 Functional Test Point PASS!!!
             [  52000 ns] Test is running, debug_wb_pc = 0xbfc3ad58
             [  62000 ns] Test is running, debug_wb_pc = 0xbfc3c260
     ----[  71115 ns] Number 8'd04 Functional Test Point PASS!!!
             [  72000 ns] Test is running, debug_wb_pc = 0xbfc23898
             [  82000 ns] Test is running, debug_wb_pc = 0xbfc24c40
             [  92000 ns] Test is running, debug_wb_pc = 0xbfc2621c
             [ 102000 ns] Test is running, debug_wb_pc = 0xbfc2776c
     ----[ 104845 ns] Number 8'd05 Functional Test Point PASS!!!
             [ 112000 ns] Test is running, debug_wb_pc = 0xbfc4a0ac
     ----[ 117885 ns] Number 8'd06 Functional Test Point PASS!!!
             [ 122000 ns] Test is running, debug_wb_pc = 0xbfc6a68c
             [ 132000 ns] Test is running, debug_wb_pc = 0xbfc6b62c
             [ 142000 ns] Test is running, debug_wb_pc = 0xbfc6c5cc
     ----[ 144265 ns] Number 8'd07 Functional Test Point PASS!!!
             [ 152000 ns] Test is running, debug_wb_pc = 0xbfc509e4
             [ 162000 ns] Test is running, debug_wb_pc = 0xbfc51984
     ----[ 167675 ns] Number 8'd08 Functional Test Point PASS!!!
             [ 172000 ns] Test is running, debug_wb_pc = 0xbfc03bb0
             [ 182000 ns] Test is running, debug_wb_pc = 0xbfc04b50
     ----[ 185575 ns] Number 8'd09 Functional Test Point PASS!!!
             [ 192000 ns] Test is running, debug_wb_pc = 0xbfc3e008
             [ 202000 ns] Test is running, debug_wb_pc = 0xbfc3efa8
     ----[ 203475 ns] Number 8'd10 Functional Test Point PASS!!!
             [ 212000 ns] Test is running, debug_wb_pc = 0xbfc6f800
             [ 222000 ns] Test is running, debug_wb_pc = 0xbfc707a0
     ----[ 222735 ns] Number 8'd11 Functional Test Point PASS!!!
             [ 232000 ns] Test is running, debug_wb_pc = 0xbfc02648
     ----[ 237365 ns] Number 8'd12 Functional Test Point PASS!!!
             [ 242000 ns] Test is running, debug_wb_pc = 0xbfc3faec
             [ 252000 ns] Test is running, debug_wb_pc = 0xbfc40f3c
     ----[ 261915 ns] Number 8'd13 Functional Test Point PASS!!!
             [ 262000 ns] Test is running, debug_wb_pc = 0xbfc00d58
             [ 272000 ns] Test is running, debug_wb_pc = 0xbfc64ab8
             [ 282000 ns] Test is running, debug_wb_pc = 0xbfc65db8
             [ 292000 ns] Test is running, debug_wb_pc = 0xbfc67094
     ----[ 296425 ns] Number 8'd14 Functional Test Point PASS!!!
             [ 302000 ns] Test is running, debug_wb_pc = 0xbfc84484
             [ 312000 ns] Test is running, debug_wb_pc = 0xbfc85814
             [ 322000 ns] Test is running, debug_wb_pc = 0xbfc86b8c
     ----[ 330855 ns] Number 8'd15 Functional Test Point PASS!!!
             [ 332000 ns] Test is running, debug_wb_pc = 0xbfc7a0f0
     ----[ 333825 ns] Number 8'd16 Functional Test Point PASS!!!
     ----[ 336795 ns] Number 8'd17 Functional Test Point PASS!!!
     ----[ 338455 ns] Number 8'd18 Functional Test Point PASS!!!
     ----[ 340625 ns] Number 8'd19 Functional Test Point PASS!!!
             [ 342000 ns] Test is running, debug_wb_pc = 0xbfc87f18
     ----[ 342805 ns] Number 8'd20 Functional Test Point PASS!!!
             [ 352000 ns] Test is running, debug_wb_pc = 0xbfc8006c
             [ 362000 ns] Test is running, debug_wb_pc = 0xbfc8100c
     ----[ 364615 ns] Number 8'd21 Functional Test Point PASS!!!
             [ 372000 ns] Test is running, debug_wb_pc = 0xbfc0b1c8
             [ 382000 ns] Test is running, debug_wb_pc = 0xbfc0c168
     ----[ 385015 ns] Number 8'd22 Functional Test Point PASS!!!
             [ 392000 ns] Test is running, debug_wb_pc = 0xbfc332a8
             [ 402000 ns] Test is running, debug_wb_pc = 0xbfc34248
     ----[ 406375 ns] Number 8'd23 Functional Test Point PASS!!!
             [ 412000 ns] Test is running, debug_wb_pc = 0xbfc61798
             [ 422000 ns] Test is running, debug_wb_pc = 0xbfc62738
             [ 432000 ns] Test is running, debug_wb_pc = 0xbfc636d8
     ----[ 432785 ns] Number 8'd24 Functional Test Point PASS!!!
             [ 442000 ns] Test is running, debug_wb_pc = 0xbfc7b564
             [ 452000 ns] Test is running, debug_wb_pc = 0xbfc7c504
     ----[ 456195 ns] Number 8'd25 Functional Test Point PASS!!!
             [ 462000 ns] Test is running, debug_wb_pc = 0xbfc4d470
             [ 472000 ns] Test is running, debug_wb_pc = 0xbfc4e410
     ----[ 481535 ns] Number 8'd26 Functional Test Point PASS!!!
             [ 482000 ns] Test is running, debug_wb_pc = 0xbfc6cfc8
             [ 492000 ns] Test is running, debug_wb_pc = 0xbfc6df68
     ----[ 499435 ns] Number 8'd27 Functional Test Point PASS!!!
             [ 502000 ns] Test is running, debug_wb_pc = 0xbfc8a360
             [ 512000 ns] Test is running, debug_wb_pc = 0xbfc8b300
             [ 522000 ns] Test is running, debug_wb_pc = 0xbfc8c2a0
     ----[ 525825 ns] Number 8'd28 Functional Test Point PASS!!!
             [ 532000 ns] Test is running, debug_wb_pc = 0xbfc78914
             [ 542000 ns] Test is running, debug_wb_pc = 0xbfc798b4
     ----[ 546225 ns] Number 8'd29 Functional Test Point PASS!!!
             [ 552000 ns] Test is running, debug_wb_pc = 0xbfc475a4
             [ 562000 ns] Test is running, debug_wb_pc = 0xbfc48544
             [ 572000 ns] Test is running, debug_wb_pc = 0xbfc494e4
     ----[ 572635 ns] Number 8'd30 Functional Test Point PASS!!!
             [ 582000 ns] Test is running, debug_wb_pc = 0xbfc09260
             [ 592000 ns] Test is running, debug_wb_pc = 0xbfc0a200
     ----[ 593035 ns] Number 8'd31 Functional Test Point PASS!!!
             [ 602000 ns] Test is running, debug_wb_pc = 0xbfc76b40
             [ 612000 ns] Test is running, debug_wb_pc = 0xbfc77ae0
     ----[ 615165 ns] Number 8'd32 Functional Test Point PASS!!!
             [ 622000 ns] Test is running, debug_wb_pc = 0xbfc42d9c
             [ 632000 ns] Test is running, debug_wb_pc = 0xbfc43d3c
     ----[ 634365 ns] Number 8'd33 Functional Test Point PASS!!!
             [ 642000 ns] Test is running, debug_wb_pc = 0xbfc0d4ac
             [ 652000 ns] Test is running, debug_wb_pc = 0xbfc0e44c
     ----[ 656735 ns] Number 8'd34 Functional Test Point PASS!!!
             [ 662000 ns] Test is running, debug_wb_pc = 0xbfc06b28
             [ 672000 ns] Test is running, debug_wb_pc = 0xbfc07ac8
     ----[ 676065 ns] Number 8'd35 Functional Test Point PASS!!!
             [ 682000 ns] Test is running, debug_wb_pc = 0xbfc5bc14
             [ 692000 ns] Test is running, debug_wb_pc = 0xbfc5cbb4
     ----[ 698445 ns] Number 8'd36 Functional Test Point PASS!!!
             [ 702000 ns] Test is running, debug_wb_pc = 0xbfc565fc
             [ 712000 ns] Test is running, debug_wb_pc = 0xbfc57bfc
             [ 722000 ns] Test is running, debug_wb_pc = 0xbfc59250
             [ 732000 ns] Test is running, debug_wb_pc = 0xbfc5a8d4
     ----[ 736645 ns] Number 8'd37 Functional Test Point PASS!!!
             [ 742000 ns] Test is running, debug_wb_pc = 0xbfc1eaec
             [ 752000 ns] Test is running, debug_wb_pc = 0xbfc20170
             [ 762000 ns] Test is running, debug_wb_pc = 0xbfc217e4
             [ 772000 ns] Test is running, debug_wb_pc = 0xbfc22e94
     ----[ 774605 ns] Number 8'd38 Functional Test Point PASS!!!
             [ 782000 ns] Test is running, debug_wb_pc = 0xbfc718dc
             [ 792000 ns] Test is running, debug_wb_pc = 0xbfc72f24
             [ 802000 ns] Test is running, debug_wb_pc = 0xbfc7456c
             [ 812000 ns] Test is running, debug_wb_pc = 0xbfc75be4
     ----[ 812805 ns] Number 8'd39 Functional Test Point PASS!!!
             [ 822000 ns] Test is running, debug_wb_pc = 0xbfc53414
             [ 832000 ns] Test is running, debug_wb_pc = 0xbfc548ec
             [ 842000 ns] Test is running, debug_wb_pc = 0xbfc55d4c
     ----[ 842485 ns] Number 8'd40 Functional Test Point PASS!!!
             [ 852000 ns] Test is running, debug_wb_pc = 0xbfc29d0c
             [ 862000 ns] Test is running, debug_wb_pc = 0xbfc2b0e0
             [ 872000 ns] Test is running, debug_wb_pc = 0xbfc2c480
             [ 882000 ns] Test is running, debug_wb_pc = 0xbfc2d884
     ----[ 886735 ns] Number 8'd41 Functional Test Point PASS!!!
             [ 892000 ns] Test is running, debug_wb_pc = 0xbfc18e80
             [ 902000 ns] Test is running, debug_wb_pc = 0xbfc1a2a0
             [ 912000 ns] Test is running, debug_wb_pc = 0xbfc1b658
             [ 922000 ns] Test is running, debug_wb_pc = 0xbfc1c9f4
             [ 932000 ns] Test is running, debug_wb_pc = 0xbfc1ddcc
     ----[ 933015 ns] Number 8'd42 Functional Test Point PASS!!!
             [ 942000 ns] Test is running, debug_wb_pc = 0xbfc121b8
             [ 952000 ns] Test is running, debug_wb_pc = 0xbfc13318
             [ 962000 ns] Test is running, debug_wb_pc = 0xbfc14478
             [ 972000 ns] Test is running, debug_wb_pc = 0xbfc155d8
             [ 982000 ns] Test is running, debug_wb_pc = 0xbfc16728
     ----[ 983765 ns] Number 8'd43 Functional Test Point PASS!!!
             [ 992000 ns] Test is running, debug_wb_pc = 0x00000000
             [1002000 ns] Test is running, debug_wb_pc = 0x00000000
             [1012000 ns] Test is running, debug_wb_pc = 0xbfc7e440
             [1022000 ns] Test is running, debug_wb_pc = 0x00000000
             [1032000 ns] Test is running, debug_wb_pc = 0xbfc7ed14
             [1042000 ns] Test is running, debug_wb_pc = 0x00000000
     ----[1043835 ns] Number 8'd44 Functional Test Point PASS!!!
             [1052000 ns] Test is running, debug_wb_pc = 0xbfc0ef50
             [1062000 ns] Test is running, debug_wb_pc = 0x00000000
             [1072000 ns] Test is running, debug_wb_pc = 0xbfc0f824
             [1082000 ns] Test is running, debug_wb_pc = 0x00000000
             [1092000 ns] Test is running, debug_wb_pc = 0x00000000
             [1102000 ns] Test is running, debug_wb_pc = 0x00000000
             [1112000 ns] Test is running, debug_wb_pc = 0x00000000
             [1122000 ns] Test is running, debug_wb_pc = 0xbfc10e7c
     ----[1131265 ns] Number 8'd45 Functional Test Point PASS!!!
             [1132000 ns] Test is running, debug_wb_pc = 0xbfc349e4
             [1142000 ns] Test is running, debug_wb_pc = 0xbfc35984
             [1152000 ns] Test is running, debug_wb_pc = 0xbfc36924
     ----[1154805 ns] Number 8'd46 Functional Test Point PASS!!!
             [1162000 ns] Test is running, debug_wb_pc = 0xbfc8240c
             [1172000 ns] Test is running, debug_wb_pc = 0xbfc833ac
     ----[1176105 ns] Number 8'd47 Functional Test Point PASS!!!
             [1182000 ns] Test is running, debug_wb_pc = 0xbfc88c94
     ----[1185635 ns] Number 8'd48 Functional Test Point PASS!!!
             [1192000 ns] Test is running, debug_wb_pc = 0xbfc17f80
     ----[1195145 ns] Number 8'd49 Functional Test Point PASS!!!
             [1202000 ns] Test is running, debug_wb_pc = 0xbfc60c04
     ----[1204035 ns] Number 8'd50 Functional Test Point PASS!!!
     ----[1209165 ns] Number 8'd51 Functional Test Point PASS!!!
             [1212000 ns] Test is running, debug_wb_pc = 0xbfc0337c
     ----[1215135 ns] Number 8'd52 Functional Test Point PASS!!!
     ----[1221745 ns] Number 8'd53 Functional Test Point PASS!!!
             [1222000 ns] Test is running, debug_wb_pc = 0xbfc00d94
     ----[1228035 ns] Number 8'd54 Functional Test Point PASS!!!
             [1232000 ns] Test is running, debug_wb_pc = 0x00000000
     ----[1234645 ns] Number 8'd55 Functional Test Point PASS!!!
     ----[1241885 ns] Number 8'd56 Functional Test Point PASS!!!
             [1242000 ns] Test is running, debug_wb_pc = 0xbfc00d60
     ----[1248485 ns] Number 8'd57 Functional Test Point PASS!!!
             [1252000 ns] Test is running, debug_wb_pc = 0xbfc4fa0c
     ----[1253335 ns] Number 8'd58 Functional Test Point PASS!!!
             [1262000 ns] Test is running, debug_wb_pc = 0xbfc37e08
             [1272000 ns] Test is running, debug_wb_pc = 0xbfc38d3c
     ----[1277255 ns] Number 8'd59 Functional Test Point PASS!!!
             [1282000 ns] Test is running, debug_wb_pc = 0xbfc67fc4
             [1292000 ns] Test is running, debug_wb_pc = 0xbfc68ee0
             [1302000 ns] Test is running, debug_wb_pc = 0xbfc69e00
     ----[1302835 ns] Number 8'd60 Functional Test Point PASS!!!
             [1312000 ns] Test is running, debug_wb_pc = 0xbfc2ef90
     ----[1321725 ns] Number 8'd61 Functional Test Point PASS!!!
             [1322000 ns] Test is running, debug_wb_pc = 0xbfc00ae8
             [1332000 ns] Test is running, debug_wb_pc = 0xbfc4b900
             [1342000 ns] Test is running, debug_wb_pc = 0xbfc4c7e8
     ----[1342985 ns] Number 8'd62 Functional Test Point PASS!!!
             [1352000 ns] Test is running, debug_wb_pc = 0xbfc44da4
             [1362000 ns] Test is running, debug_wb_pc = 0xbfc45cb4
     ----[1371175 ns] Number 8'd63 Functional Test Point PASS!!!
             [1372000 ns] Test is running, debug_wb_pc = 0xbfc2ff28
             [1382000 ns] Test is running, debug_wb_pc = 0xbfc30dd0
             [1392000 ns] Test is running, debug_wb_pc = 0xbfc31cf8
     ----[1397715 ns] Number 8'd64 Functional Test Point PASS!!!
             [1402000 ns] Test is running, debug_wb_pc = 0xbfc00400
     ----[1402325 ns] Number 8'd65 Functional Test Point PASS!!!
     ----[1407145 ns] Number 8'd66 Functional Test Point PASS!!!
             [1412000 ns] Test is running, debug_wb_pc = 0xbfc0068c
     ----[1412805 ns] Number 8'd67 Functional Test Point PASS!!!
     ----[1418375 ns] Number 8'd68 Functional Test Point PASS!!!
             [1422000 ns] Test is running, debug_wb_pc = 0x00000000
     ----[1424035 ns] Number 8'd69 Functional Test Point PASS!!!
     ----[1430385 ns] Number 8'd70 Functional Test Point PASS!!!
             [1432000 ns] Test is running, debug_wb_pc = 0xbfc00678
     ----[1436755 ns] Number 8'd71 Functional Test Point PASS!!!
             [1442000 ns] Test is running, debug_wb_pc = 0xbfc004c8
     ----[1443105 ns] Number 8'd72 Functional Test Point PASS!!!
     ----[1449745 ns] Number 8'd73 Functional Test Point PASS!!!
             [1452000 ns] Test is running, debug_wb_pc = 0x00000000
     ----[1456385 ns] Number 8'd74 Functional Test Point PASS!!!
             [1462000 ns] Test is running, debug_wb_pc = 0x00000000
     ----[1462895 ns] Number 8'd75 Functional Test Point PASS!!!
     ----[1468805 ns] Number 8'd76 Functional Test Point PASS!!!
             [1472000 ns] Test is running, debug_wb_pc = 0xbfc005ec
     ----[1476575 ns] Number 8'd77 Functional Test Point PASS!!!
             [1482000 ns] Test is running, debug_wb_pc = 0xbfc00384
     ----[1490295 ns] Number 8'd78 Functional Test Point PASS!!!
             [1492000 ns] Test is running, debug_wb_pc = 0xbfc0046c
             [1502000 ns] Test is running, debug_wb_pc = 0xbfc6cf10
     ----[1504015 ns] Number 8'd79 Functional Test Point PASS!!!
             [1512000 ns] Test is running, debug_wb_pc = 0x00000000
     ----[1517735 ns] Number 8'd80 Functional Test Point PASS!!!
             [1522000 ns] Test is running, debug_wb_pc = 0x00000000
     ----[1531455 ns] Number 8'd81 Functional Test Point PASS!!!
             [1532000 ns] Test is running, debug_wb_pc = 0xbfc003fc
             [1542000 ns] Test is running, debug_wb_pc = 0xbfc0038c
     ----[1545175 ns] Number 8'd82 Functional Test Point PASS!!!
             [1552000 ns] Test is running, debug_wb_pc = 0xbfc004dc
     ----[1558895 ns] Number 8'd83 Functional Test Point PASS!!!
             [1562000 ns] Test is running, debug_wb_pc = 0x00000000
             [1572000 ns] Test is running, debug_wb_pc = 0xbfc00380
     ----[1572625 ns] Number 8'd84 Functional Test Point PASS!!!
             [1582000 ns] Test is running, debug_wb_pc = 0xbfc0039c
     ----[1586365 ns] Number 8'd85 Functional Test Point PASS!!!
             [1592000 ns] Test is running, debug_wb_pc = 0xbfc00498
     ----[1600095 ns] Number 8'd86 Functional Test Point PASS!!!
             [1602000 ns] Test is running, debug_wb_pc = 0xbfc46a78
             [1612000 ns] Test is running, debug_wb_pc = 0xbfc003b8
     ----[1613825 ns] Number 8'd87 Functional Test Point PASS!!!
             [1622000 ns] Test is running, debug_wb_pc = 0xbfc00394
     ----[1627555 ns] Number 8'd88 Functional Test Point PASS!!!
             [1632000 ns] Test is running, debug_wb_pc = 0xbfc00484
     ----[1641285 ns] Number 8'd89 Functional Test Point PASS!!!
     ==============================================================
     Test end!
     ----PASS!!!
     $finish called at time : 1641885 ns : File "D:/practice_code/subject/hardware_design/soc_sram_func/testbench/mycpu_tb.v" Line 261
     run: Time (s): cpu = 00:00:32 ; elapsed = 00:00:29 . Memory (MB): peak = 1480.160 ; gain = 0.000
     
     ```

   * 通过





### 遇到的主要问题

1. 初始化inst_mem的IP时，指令一直默认跳动间隔为3。

2. Hilo寄存器的相关指令mfhi，mflo他们读的数据是Hilo寄存器中读出来的然后写到rs的，这两条指令没有问题，但是mthi，mtlo这两条指令要想Hilo寄存器写，就感觉不知道如何处理。

   最后又仔细看数据通路图，发现ex阶段是有一个输出信号用来判断是否向Hilo寄存器写数据的，

![image-20201230130003091](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201230130003091.png)

只要要写寄存器的时候像将whilo_o信号置位1即可

3. 对于Hilo寄存器的操作这里有一些问题![image-20201230165740209](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201230165740209.png)
   
   * 这里是mfhi指令，说明mfhi指令的实现有误，最后发现是`define EXE_RES_SHIFT 3'b010 与宏定义 `define EXE_RES_HILO 3'b010 重复，导致出现二义性。
   
4. 关于Hilo寄存器的实现是完全参照《自己动手写cpu》的实现的。

5. I型指令容易忘记对立即数进行赋值和改变写寄存器号。

6. 在实现div和divu指令时，出现了一个问题，这个问题是由流水线暂停不成功引起的，如下：

   * ![image-20210101170220795](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210101170220795.png)
   * 暂停请求已发出，pc也跟着暂停了，但是取指令操作依然没有暂停，而是等到了下一个周期才暂停。
   * 原始关于更新pc的代码块

   * ```verilog
     always @ (posedge clk) begin  
     		if (ce == `ChipDisable) begin
     			pc <= 32'h00000000;
     		end else if(stall[0] == 0) begin
     		  		pc <= pc + 4'h4;
     		end
     	end
     ```

   * D触发器原理，clk控制的，时钟上升沿的时候stall变为1，读到的还是0，更新代码如下

   * ```verilog
     always @ (negedge clk) begin  // 重要的事情说三遍,这里要改为下降沿!!!
     		if (ce == `ChipDisable) begin
     			pc <= 32'h00000000;
     		end else if(stall[0] == 0) begin
     		  		pc <= pc + 4'h4;
     		end
     	end
     ```

   * 解决

7. ip核这里用生成用的自己又勾选了这个选项![image-20210102002711423](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210102002711423.png)

   * 造成后面pc错位，重新将ip核去掉这个选项.
   
8. 对于分支指令，在译码时忘了需要有判断条件，直接照着无条件判断做的，造成一些错误。

9. 在验证取指译码阶段的时候，查看要写回的数据，发现第一条指令的写回数据要提前一个周期，其他指令均正常，如下：

   * ![image-20210103151833762](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210103151833762.png)
   * 后面发现是由于第一个指令在译圈起来的部分占据两个周期，所以他在这里就有两个执行阶段.




**52条指令测试**

3. 测试文件中resetn要取反调用

4. 利用将已经完成的openmips放到测试文件进行测试，出现pc不对齐的情况，

   * 解决方法，如下，方框框起来的部分要与椭圆圈起来的部分pc的上升沿和下降沿要区分开来，修改regfile的改变信号为下降沿，将pc_reg.v的时钟控制信号改回上升沿，同时在调用openmips.v的soc_lite_top.v里，给openmips 输入时钟信号取反（由于数据存储器和指令存储器都是在soc_lite_top中被调用），这样的话指令存储器，数据存储器，寄存器堆的信号就都是上升沿控制。

   * ![image-20210103193654731](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210103193654731.png)

     * regfile.v主要修改

     * ```verilog
       always @ (negedge clk) begin  // 这里要修改为下降沿，相当于模块内与模块间的时钟沿要错开
       		if (rst == `RstDisable) begin
       			if((we == `WriteEnable) && (waddr != `RegNumLog2'h0)) begin
       				regs[waddr] <= wdata;
       			end
       		end
       	end
       ```

     * pc_reg.v主要修改

     * ```verilog
       always @ (posedge clk) begin  // 
       		if (ce == `ChipDisable) begin
       			pc <= 32'hbfc0_0000;
       		end else if(stall[0] == 0) begin
       			if (branch_flag_i == 1'b1) begin
       				pc <= branch_target_address_i;
       			end else begin
       				pc <= pc + 4'h4;
       			end
       		end 
       	en
       ```

   

5. 控制台报错如下：

   * ```assembly
     Test begin!
     --------------------------------------------------------------
     [   2317 ns] Error!!!
         reference: PC = 0x9fc06b50, wb_rf_wnum = 0x10, wb_rf_wdata = 0x00000001
         mycpu    : PC = 0x0fc06b50, wb_rf_wnum = 0x10, wb_rf_wdata = 0x00000001
     --------------------------------------------------------------
     $finish called at time : 2357 ns : File "D:/practice_code/subject/hardware_design/soc_sram_func/testbench/mycpu_tb.v" Line 160
     
     ```

   * 报错指令`bfc00704:	0ff01ad4 	jal	bfc06b50 <n1_lui_test>`

   * 返回查看

     * ![image-20210103201809398](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210103201809398.png)

   * 原因，`branch_target_address_o`返回地址没有pc+4.

   * 修改过后，依然报和上面一样的错，进入id.v中继续找，终于找到了错误原因。现在的`branch_target_address_o <= {pc_plus_4[31:28], imm_sll2_signedext_j};`而定义的imm_sll2_signedext_j是这样的wire[ \`RegBus] imm_sll2_signedext_j; 定义的是32位，重新修改`branch_target_address_o <= {pc_plus_4[31:28], imm_sll2_signedext_j[27:0]};`

6. 控制台报错如下：

   * ```assembly
     ==============================================================
     Test begin!
     ----[  14025 ns] Number 8'd01 Functional Test Point PASS!!!
     --------------------------------------------------------------
     [  14117 ns] Error!!!
         reference: PC = 0x9fc00abc, wb_rf_wnum = 0x0a, wb_rf_wdata = 0x00000000
         mycpu    : PC = 0x9fc00abc, wb_rf_wnum = 0x0a, wb_rf_wdata = 0xbfafaaaa
     --------------------------------------------------------------
     ```

   * 出错指令如下：

     * ```assembly
       bfc00ab0:	3508f02c 	ori	t0,t0,0xf02c
       /home/ghj/Desktop/func/start.S:537
       bfc00ab4:	3409aaaa 	li	t1,0xaaaa
       /home/ghj/Desktop/func/start.S:540
       bfc00ab8:	8d0a0000 	lw	t2,0(t0)
       /home/ghj/Desktop/func/start.S:541
       bfc00abc:	01495026 	xor	t2,t2,t1
       ```

   * ![image-20210103231946263](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210103231946263.png)
   * 写得都正确，说明lw数据前推有问题。检查id.v，最后发现是lw指令的暂停请求没有发出来，因为参照书上写的，他的暂停是后面加上的。将`assign stallreq = 0; //这里暂时没有暂停请求`注释掉。

7. 控制台报错如下：

   * ```assembly
     --------------------------------------------------------------
     [ 105257 ns] Error!!!
         reference: PC = 0xbfc35f44, wb_rf_wnum = 0x02, wb_rf_wdata = 0xc822c7e8
         mycpu    : PC = 0xbfc35f44, wb_rf_wnum = 0x02, wb_rf_wdata = 0x800d34b8
     --------------------------------------------------------------
     ```

   * ![image-20210104133212147](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210104133212147.png)

   * 猜测是没存进去或者是没取出来，后面请教学长才发现当要读的时候wen要置为全0，这个问题的主要是字节选择信号哪里给的是全1.

   * ![image-20210104133456166](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210104133456166.png)

   * 将所有要读的数据这里的`mem_sel_o`全置为0，这个测试点通过。

8. 控制台报错如下

   * ```assembly
     --------------------------------------------------------------
     [ 237727 ns] Error!!!
         reference: PC = 0xbfc28f48, wb_rf_wnum = 0x02, wb_rf_wdata = 0x42ea0000
         mycpu    : PC = 0x8fc28f48, wb_rf_wnum = 0x02, wb_rf_wdata = 0x42ea0000
     --------------------------------------------------------------
     ```

   * ![image-20210104151029095](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210104151029095.png)

   * 翻id.v的代码，发现是没有定义pc_plus8，修改之后通过`soft/func_part/obj_1/inst_rom.coe`，其中trace对比文件位于`cpu132_gettrace/goden_trace.txt`.


**57条指令测试（加入特权内陷指令）**

1. 控制台报错如下

   * ```assembly
     ==============================================================
     Test begin!
     --------------------------------------------------------------
     [   2087 ns] Error!!!
         reference: PC = 0xbfc00000, wb_rf_wnum = 0x08, wb_rf_wdata = 0xffffffff
         mycpu    : PC = 0xbfc00380, wb_rf_wnum = 0x1a, wb_rf_wdata = 0x00000000
     --------------------------------------------------------------
     ```

     

   * ![image-20210105174559232](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210105174559232.png)

   * 原因是空指令错设置为非法指令，id.v修改如下

   * ```verilog
     instvalid <= (inst_i == `ZeroWord) ? `InstValid :`InstInvalid;	   // 空指令默认为有效指令
     ```

2. 控制台报错如下

   * ```assembly
     --------------------------------------------------------------
     [  14427 ns] Error!!!
         reference: PC = 0xbfc04a64, wb_rf_wnum = 0x17, wb_rf_wdata = 0x00400000
         mycpu    : PC = 0xbfc00380, wb_rf_wnum = 0x1a, wb_rf_wdata = 0x00000000
     --------------------------------------------------------------
     ```

   * ![image-20210105183141350](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210105183141350.png)

   * 提示mtc0是无效指令，后来发现是把mtc指令单个在另一个always模块，导致出错，修改即可。

3. 控制台报错如下

   * ```assembly
     [  15067 ns] Error!!!
         reference: PC = 0xbfc003f4, wb_rf_wnum = 0x1a, wb_rf_wdata = 0xbfc04a9c
         mycpu    : PC = 0xbfc003f4, wb_rf_wnum = 0x1a, wb_rf_wdata = 0x00000000
     ```

   * ![image-20210106002027943](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210106002027943.png)

   * ```verilog
     end else if(aluop_i == `EXE_MFC0_OP) begin  
     			// cp0_reg_read_addr_o <= inst_i[15:11];
     			// Hilores      <= cp0_reg_data_i; 
     			if(mem_cp0_reg_we && (mem_cp0_reg_write_addr == inst_i[15:11]) ) begin  // 这个地方一定要注意顺序(mem阶段的才是最新的)
     				cp0_reg_read_addr_o <= inst_i[15:11];
     				Hilores             <= mem_cp0_reg_data;
     			end else if (wb_cp0_reg_we && (wb_cp0_reg_write_addr == inst_i[15:11]) ) begin
     				cp0_reg_read_addr_o <= inst_i[15:11];
     				Hilores      <= wb_cp0_reg_data;
     			end else begin
     				cp0_reg_read_addr_o <= inst_i[15:11];
     				Hilores      <= cp0_reg_data_i;
     			end
     ```

   * 按理说Hilores应该为cp0_reg_data_i， 但是这里即使前两个条件不满足，这里也是0，最后找了好久，发现另有一个always模块是这样写的。

   * ```verilog
     always @ (*) begin
     	...
         default:				begin
        	 Hilores <= `ZeroWord;  // 这
         end
         ...
     end
     ```

   * 这个default真的是……

4. 控制台报错如下

   * ```assembly
     --------------------------------------------------------------
     [  40897 ns] Error!!!
         reference: PC = 0xbfc00380, wb_rf_wnum = 0x1a, wb_rf_wdata = 0x00018027
         mycpu    : PC = 0xbfc029cc, wb_rf_wnum = 0x02, wb_rf_wdata = 0x00000000
     --------------------------------------------------------------
     ```

   * mem_wb.v中的flush信号没连上线。找了半天，到最后发现cp0协处理器没有定义关于badaddr的寄存器（因为书上没有讲到这个，而测试点又有这个），定义这个寄存器，通过。

5. 控制台报错如下

   * ![image-20210106195604002](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210106195604002.png)

   * ![image-20210106195647978](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210106195647978.png)

   * 从epc中读入数据，其中是延迟槽指令的地址，可以看到两个相差4，找了半天，最后发现对应的分支跳转指令是有条件跳转（beqz），实际上这条指令不满足跳转，但是在《自己动手写CPU》的书中，对于延迟槽指令，他的定义是只有跳转发生后面才是……后面我们将延迟槽指令改为只要该指令是分支跳转指令，不管发不发生跳转，后面的指令都定义为延迟槽指令，即：

     * ```verilog
       `EXE_BEQ:			begin
           wreg_o <= `WriteDisable;		aluop_o <= `EXE_BEQ_OP;
           alusel_o <= `EXE_RES_JUMP_BRANCH; reg1_read_o <= 1'b1;	reg2_read_o 	<= 1'b1;
           instvalid <= `InstValid;	
           next_inst_in_delayslot_o <= `InDelaySlot;
           if(reg1_o == reg2_o) begin
               branch_target_address_o <= pc_plus_4+ imm_sll2_signedext_b;
               branch_flag_o <= `Branch;
               // next_inst_in_delayslot_o <= `InDelaySlot;		  	
           end
       end
       ```

   * 测试通过。

**测试full**

1. 控制台报错如下

   * ```assembly
     --------------------------------------------------------------
     [1303277 ns] Error!!!
         reference: PC = 0xbfc2e240, wb_rf_wnum = 0x02, wb_rf_wdata = 0x00002560
         mycpu    : PC = 0xbfc00380, wb_rf_wnum = 0x1a, wb_rf_wdata = 0x00004000
     --------------------------------------------------------------
     ```

   * ![image-20210106203526076](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210106203526076.png)

   * 对比报错pc，可以看到本来不应该触发异常，但是这里却触发了异常，查看ex.v中的lh地址例外判断，修改如下

   * ```verilog
     `EXE_LH_OP, `EXE_LHU_OP: begin
         // if (mem_addr_o[1:0]!=2'b00 || mem_addr_o[1:0]!=2'b10) begin
         if (mem_addr_o[1:0]!=2'b00 && mem_addr_o[1:0]!=2'b10) begin
         	badaddr_read_fetch <= 1; 
         end
     end
     ```

   * 通过test_full.



