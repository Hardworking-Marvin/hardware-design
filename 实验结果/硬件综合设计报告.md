
<div align='center' ><font size='60'>MIPS SOC报告</font></div>

<p align="right">胡卫、刘玉莽、赵雪松</p>																								



#### 1 设计简介

​	将《组成原理》实验 4 实现的简易五级流水线 CPU，由十条指令扩展为 57 条指令，并实现异常处理模块。 其中包括所有非浮点 MIPS I 指令(除去 LWL、LWR、SWL、SWR)以及 MIPS 32 中的 ERET 指令，有 14 条算术运算指令、8 条逻辑运算指令、6 条移 位指令、12 条分支指令、4 条数据移动指令、2 条自陷指令、8 条访存指 令、3 条特权指令，总计 57 条指令。 实现了硬综要求处理的7种异常（中断、读数据或取地址例外、写数据例外、系统调用例外、断点例外、保留指令例外、算术溢出例外）。连接了soc接口以及axi接口，同时加入了写直达的cache，加快 CPU 访存速度。cache基本属性是 4KB 大小，块大小为 1word， 处理方式为写直达、直接映射的 I-Cache 与 D-Cache。

​	通过实验测试，我们可以通过soc接口测试（89个测试点），axi接口测试（89个测试点），以及axi的10个性能测试小程序（bitconut, bubble_sort, coremark, crc32, dhystone, quick_sort, select_sort, sha, stream_copy, stringsearch）。

**1.1 小组分工说明**

* 胡卫：负责数据移动指令以及算术运算指令，6类独立指令的测试，soc接口的连接，52条指令的测试，57条指令的测试，axi接口的连接，加入cache测试，axi性能测试，实验报告撰写。
* 刘玉莽：负责分支跳转指令以及访存指令，6类独立指令的测试，soc接口的连接，52条指令的测试，57条指令的测试，加入cache测试，axi性能测试，实验错误信息记录，实验报告撰写。
* 赵雪松：负责添加逻辑运算指令以及移位指令，数据通路图，57条指令的测试，加入cache测试，axi性能测试，实验报告撰写。



#### 2 设计方案

**2.1 总体设计思路**

​		本次实验以自己动手写cpu为主题，我们小组尽力完成所要实现的cpu基本功能，最终实现的功能包括五级流水线，57条指令（52条普通指令，5条内陷特权指令），通过soc测试，连接axi接口，加入cache。下面是我们小组总体设计思路的详细说明。

**2.1.1 整个系统的工作机制**

![image-20210108172131634](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210108172131634.png)

​	上面这个图是一个目前我们所实现的简单的系统结构图（具体数据通路图"实验结果/数据通路图.svg"）。整体工作的机制就是将我们实现的mips core通过封装，经过一个写直达cache，与axi接口相连，实现相关功能。其中我们的mips core的主要功能就是要能够正常执行的指令， 包括要求硬综要求处理的7种异常（中断、读数据或取地址例外、写数据例外、系统调用例外、断点例外、保留指令例外、算术溢出例外）。

​	通过实验测试，我们可以通过soc接口测试（89个测试点），axi接口测试（89个测试点），以及axi的10个性能测试小程序（bitconut, bubble_sort, coremark, crc32, dhystone, quick_sort, select_sort, sha, stream_copy, stringsearch）。

**2.1.2** **数据通路图**

* 数据通路图所在目录——"实验结果/数据通路图.svg"

* 部分截图

  * ![image-20210109000506983](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210109000506983.png)

  * ![image-20210109000525225](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210109000525225.png)

  * ![image-20210109000553069](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210109000553069.png)

    

**2.2 模块设计说明**

- reg_pc模块

在复位的时候，输出的指令存储器使能信号为ChipDIsable，表示指令存储器禁用，其余时刻指令存储器使能信号为ChipEnable，表示指令存储器使能。当指令存储器禁用时，PC的值保持为0，当指令存储器能使用时，PC的值会在每时钟周期加4，表示下一条指令的地址。

| 接口名称                | 宽度（bit） | in/out | 作用                                |
| :---------------------- | ----------- | ------ | :---------------------------------- |
| clk                     | 1           | in     | 时钟                                |
| rst                     | 1           | in     | 复位                                |
| branch_flag_i           | 1           | in     | 下条指令是否跳转                    |
| branch_target_address_i | 32          | in     | 跳转的目标地址                      |
| stall                   | 6           | in     | 控制模块ctrl输出的控制信息是否stall |
| flush                   | 1           | in     | 流水线是否清除                      |
| new_pc                  | 32          | in     | 异常处理地址                        |
| pc                      | 32          | out    | 存储下一条指令的地址                |
| ce                      | 1           | out    | 改变使能端信号                      |

- regfile
  - 寄存器堆含有32个寄存器，可以通过接口读指定的寄存器值或写制定寄存器

| 接口名称 | 宽度（bit） | in/out | 作用         |
| :------- | ----------- | ------ | :----------- |
| clk      | 1           | in     | 时钟信号     |
| rst      | 1           | in     | 复位信号     |
| we       | 1           | in     | 写使能       |
| waddr    | 5           | in     | 要写入的地址 |
| wdata    | 32          | in     | 要写的数据   |
| re1      | 1           | in     | 读使能       |
| raddr1   | 5           | in     | 要读的地址   |
| rdata1   | 32          | out    | 要读的数据   |
| re2      | 1           | in     | 读使能       |
| raddr2   | 32          | in     | 要读的地址   |
| rdata2   | 32          | out    | 要读的数据   |

- div
  - 除法运算，除法会暂停流水线知道除法运算结束，输出的64位结果写到hilo寄存器

| 接口名称     | 宽度（bit） | in/out | 作用                 |
| :----------- | ----------- | ------ | :------------------- |
| clk          | 1           | in     | 时钟信号             |
| rst          | 1           | in     | 复位信号             |
| signed_div_i | 1           | in     | 是否是有符号乘法     |
| opdata1_i    | 32          | in     | 被除数               |
| opdata2_i    | 32          | in     | 除数                 |
| start_i      | 1           | in     | 是否开始             |
| annul_i      | 1           | in     | 是否强制结束除法运算 |
| result_o     | 64          | out    | 除法结果             |
| ready_o      | 1           | out    | 除法是否结束         |

- mmu
  - 将cpu的虚拟地址转换为内存的物理地址

| 接口名称   | 宽度（bit） | in/out | 作用                 |
| ---------- | ----------- | ------ | -------------------- |
| inst_vaddr | 32          | in     | pc的虚拟地址         |
| data_vaddr | 32          | in     | 要访问的虚拟内存地址 |
| inst_paddr | 32          | out    | pc的物理地址         |
| data_paddr | 32          | out    | 要访问的物理内存地址 |

- if_id
  - 在该模块中，根据stall和flush信号值来决定是否将取指阶段的值传到写回阶段，当stall信号值判定暂停该阶段时，译码阶段的所有值都将保持不变；当flush为有效时，则给译码阶段传入0；当stall和flush都为无效时，则将取指阶段的所有值传到译码阶段。

| 接口名称 | 宽度（bit） | in/out | 作用                                |
| -------- | ----------- | ------ | ----------------------------------- |
| clk      | 1           | in     | 时钟                                |
| rst      | 1           | in     | 复位信号                            |
| stall    | 6           | in     | 控制模块ctrl输出的控制信息是否stall |
| flush    | 1           | in     | 流水线是否清空                      |
| if_pc    | 32          | in     | if阶段的pc虚拟地址                  |
| if_inst  | 32          | in     | 从irom读取到的指令值                |
| id_pc    | 32          | out    | id阶段的pc地址                      |
| id_inst  | 32          | out    | id阶段的指令编码                    |

- id
  - 对pc指令进行译码，得到最终运算的类型、子类型、源操作数1、源操作数2、要写入的目的寄存器地址等信息。运算类型有逻辑运算、移位运算、算术运算等。对分支指令进行译码计算确定是否跳转和跳转的地址。

| 接口名称                 | 宽度（bit） | in/out | 作用                                             |
| ------------------------ | ----------- | ------ | ------------------------------------------------ |
| rst                      | 1           | in     | 复位                                             |
| pc_i                     | 32          | in     | 输入的pc地址                                     |
| inst_i                   | 32          | in     | 输入的指令                                       |
| id_pc_o                  | 32          | out    | 输出的PC地址                                     |
| ex_wreg_i                | 1           | in     | 执行阶段是否要写寄存器                           |
| ex_wdata_i               | 32          | in     | 执行阶段要写的数据                               |
| ex_ed_i                  | 5           | in     | 要写的寄存器号                                   |
| mem_wreg_i               | 1           | in     | 访存阶段是否要写寄存器                           |
| mem_wdata_i              | 32          | in     | 访存阶段要写的数据                               |
| mem_wd_i                 | 5           | in     | 访存阶段要写的寄存器号                           |
| reg1_data_i              | 32          | in     | 寄存器堆读的一号寄存器的值                       |
| reg2_data_i              | 32          | in     | 寄存器堆独到的二号寄存器的值                     |
| excepttype_o             | 32          | in     | id模块得到的的异常信息                           |
| ex_aluop_i               | 32          | in     | 检测是否处于执行阶段的指令存在译码相关           |
| inst_o                   | 32          | out    | 输出到ex阶段的指令编码                           |
| stallreq                 | 1           | out    | 从id阶段发出的暂停请求                           |
| is_in_delayslot_i        | 1           | in     | 是否为延迟槽指令                                 |
| next_inst_in_delayslot_o | 1           | out    | 现在处于译码的指令是分支跳转指令并且满足跳转条件 |
| branch_flag_o            | 1           | out    | 分支指令是否跳转                                 |
| branch_target_address_o  | 32          | out    | 跳转的pc地址                                     |
| link_addr_o              | 32          | out    | 需要保存的返回地址                               |
| is_in_delayslot_o        | 1           | out    | 是否为延迟槽指令                                 |
| reg1_read_o              | 1           | out    | 是否要读寄存器1的值                              |
| reg2_read_o              | 1           | out    | 是否要读寄存器2的值                              |
| reg1_addr_o              | 5           | out    | 1号寄存器的地址                                  |
| reg2_addr_o              | 5           | out    | 2号寄存器的地址                                  |
| aluop_o                  | 8           | out    | ex阶段操作的编码                                 |
| alusel_o                 | 3           | out    | 选择alu的源操作数                                |
| reg1_o                   | 32          | out    | 寄存器堆读到的reg1的值                           |
| reg2_o                   | 32          | out    | 寄存器堆读到的reg2的值                           |
| wd_o                     | 5           | out    | 写的寄存器号                                     |
| wreg_o                   | 1           | out    | 是否写寄存器                                     |

- id_ex
  - 在该模块中，根据stall和flush信号值来决定是否将译码阶段的值传到执行阶段，当stall信号值判定暂停该阶段时，执行阶段的所有值都将保持不变；当flush为有效时，则给执行阶段传入0；当stall和flush都为无效时，则将译码阶段的所有值传到执行阶段。

| 接口名称                 | 宽度（bit） | in/out | 作用                                |
| :----------------------- | ----------- | ------ | :---------------------------------- |
| clk                      | 1           | in     | 时钟信号                            |
| rst                      | 1           | in     | 复位                                |
| stall                    | 6           | in     | 控制模块ctrl输出的控制信息是否stall |
| id2ex_pc_i               | 32          | in     | id到ex阶段的pc指令输入              |
| id2ex_pc_o               | 32          | out    | id到ex阶段的pc指令输出              |
| id_aluop                 | 8           | in     | 输出到ex阶段的操作码                |
| id_alusel                | 3           | in     | 选择alu的源操作数                   |
| id_reg1                  | 32          | in     | 输入的寄存器1的值                   |
| id_reg2                  | 32          | in     | 输入的寄存器2的值                   |
| id_wd                    | 5           | in     | 要写到的寄存器的编号                |
| id_wreg                  | 1           | ini    | 是否要写寄存器                      |
| id_link_address          | 32          | in     | 需要保存的返回地址                  |
| id_is_in_delayslot       | 1           | in     | 是否为延迟槽指令                    |
| next_inst_in_delayslot_i | 1           | in     | 下一条指令是否为延迟槽指令          |
| ex_link_address          | 32          | out    | 输出到ex阶段的返回地址              |
| ex_is_in_delayslot       | 1           | out    | 输出到ex阶段是否为延迟槽指令信号    |
| is_in_delayslot_o        | 1           | out    | 输出到id阶段是否为延迟槽指令信号    |
| flush                    | 1           | in     | 是否清除流水线                      |
| id_excepttype            | 32          | in     | id阶段输出的异常信号                |
| ex_excepttype            | 32          | out    | 输出到ex阶段的异常信号              |
| id_inst                  | 32          | in     | id阶段输出的指令编码                |
| ex_inst                  | 32          | out    | 输出到ex阶段的指令编码              |
| ex_aluop                 | 8           | out    | 输出到ex阶段的alu操作码             |
| ex_alusel                | 3           | out    | 输出到ex阶段的alu选择操作数信号     |
| ex_reg1                  | 32          | out    | 输出到ex阶段的寄存器1的值           |
| ex_reg2                  | 32          | out    | 输出到ex阶段的寄存器2的值           |
| ex_wd                    | 5           | out    | 输出到ex阶段的寄存器号              |
| ex_wreg                  | 1           | out    | 输出到ex阶段是否写寄存器            |

- ex
  - 根据id阶段的译码结果，根据aluop执行不同的运算，使用数据前推和原数据的选择进行计算，将运算的结果和写入的寄存器号传入到mem阶段。

| 接口名称               | 宽度（bit） | in/out | 作用                                        |
| :--------------------- | ----------- | ------ | :------------------------------------------ |
| rst                    | 1           | in     | 复位                                        |
| ex_pc_i                | 32          | in     | pc地址                                      |
| ex_pc_o                | 32          | out    | 输出的PC地址                                |
| aluop_i                | 8           | in     | alu操作码                                   |
| alusel_i               | 3           | in     | alu选择操作数                               |
| reg1_i                 | 32          | in     | 读到的寄存器1的值                           |
| reg2_i                 | 32          | in     | 读到的寄存器2的值                           |
| wd_i                   | 5           | in     | 要写的寄存器编号                            |
| wreg_i                 | 1           | in     | 是否要写寄存器                              |
| link_address_i         | 32          | in     | 返回的PC地址                                |
| is_in_delayslot_i      | 1           | in     | 是否在延迟槽                                |
| excepttype_i           | 32          | in     | 输入的异常信号                              |
| excepttype_o           | 32          | out    | 输出的异常信号                              |
| is_in_delayslot_o      | 1           | out    | 输出是否在延迟槽中                          |
| inst_i                 | 32          | in     | 输入的指令编码                              |
| aluop_o                | 8           | out    | 输出的alu操作码                             |
| mem_addr_o             | 32          | out    | 输出到mem阶段的地址                         |
| reg2_o                 | 32          | out    | 要输出到meme阶段的reg2的值                  |
| hi_i                   | 32          | in     | 输入的写入hilo寄存器高32位的值              |
| lo_i                   | 32          | in     | 输入的写入hilo寄存机低32位的值              |
| mem_whilo_i            | 1           | in     | mem阶段输入到ex阶段是否输入hi lo的值        |
| mem_hi_i               | 32          | in     | mem阶段输入到ex阶段hi的值                   |
| mem_lo_i               | 32          | in     | mem阶段输入到ex阶段lo的值                   |
| wb_whilo_i             | 1           | in     | wb阶段是否要输出hilo的值到ex阶段            |
| wb_hi_i                | 32          | in     | wb阶段输入到ex阶段hi的值                    |
| wb_lo_i                | 32          | in     | wb阶段输入到ex阶段lo的值                    |
| whilo_o                | 1           | out    | 是否要写hilo寄存器的值                      |
| hi_o                   | 32          | out    | 要写入的hilo寄存器hi的值                    |
| lo_o                   | 32          | out    | 要写入的hilo寄存器lo的值                    |
| mem_cp0_reg_we         | 1           | in     | 访存阶段的指令是否要写CP0，用来检测数据相关 |
| mem_cp0_reg_write_addr | 5           | in     | 要写到cp的寄存器                            |
| mem_cp0_reg_data       | 32          | in     | mem阶段要写入的寄存器的值                   |
| wb_cp0_reg_we          | 1           | in     | wb阶段是否要写cp0，用来检测数据相关         |
| wb_cp0_reg_write_addr  | 5           | in     | wb阶段要写到的cp0寄存器号                   |
| wb_cp0_reg_data        | 32          | in     | wb阶段要写到cp0的寄存器的值，用于数据前推   |
| cp0_reg_we_o           | 1           | out    | 向流水线下一级传递是否写cp0的寄存器信号     |
| cp0_reg_write_addr_o   | 5           | out    | 要写到cp0的寄存器号                         |
| cp0_reg_data_o         | 32          | out    | 要写到该cp0寄存器的值                       |
| pcFalse_o              | 1           | out    | 向流水线下一级输出是否是无效指令            |
| cp0_reg_data_i         | 32          | in     | cp0输出到ex阶段的寄存器的值                 |
| cp0_reg_read_addr_o    | 5           | out    | 要写到的cp0寄存器号                         |
| div_result_i           | 64          | in     | 除法计算的输出                              |
| div_ready_i            | 1           | in     | 除法是否计算完成                            |
| stallreq               | 1           | out    | ex阶段输出的stall请求                       |
| div_opdata1_o          | 32          | out    | 除法被除数                                  |
| div_opdata2_o          | 32          | out    | 除法的除数                                  |
| div_start_o            | 1           | out    | 除法开始                                    |
| signed_div_o           | 1           | out    | 是否是有符号除法运算                        |
| wd_o                   | 5           | out    | 要写到的寄存器编号                          |
| wreg_o                 | 1           | out    | 是否要写到寄存器                            |
| wdata_o                | 32          | out    | 要写到寄存器的值                            |

- ex_mem
  - 在该模块中，根据stall和flush信号值来决定是否将执行阶段的值传到访存阶段，当stall信号值判定暂停该阶段时，访存阶段的所有值都将保持不变；当flush为有效时，则给访存阶段传入0；当stall和flush都为无效时，则将执行阶段的所有值传到访存阶段。

| 接口名称               | 宽度（bit） | in/out | 作用                                             |
| :--------------------- | ----------- | ------ | :----------------------------------------------- |
| clk                    | 1           | in     | 时钟信号                                         |
| rst                    | 1           | in     | 复位信号                                         |
| stall                  | 6           | in     | ctrl输出的6位暂停信号                            |
| ex2mem_pc_i            | 32          | in     | 执行阶段输出到访存阶段的输入                     |
| ex2mem_pc_o            | 32          | out    | 执行阶段输出到访存阶段的输出                     |
| ex_wd                  | 5           | in     | 执行阶段要写到的寄存器号                         |
| ex_wreg                | 1           | in     | 执行阶段是否要写寄存器                           |
| ex_wdata               | 32          | in     | 执行阶段要写到寄存器的值                         |
| ex_aluop               | 8           | in     | 执行阶段的操作码                                 |
| ex_mem_addr            | 32          | in     | 执行阶段输出到访存阶段的数据地址                 |
| ex_reg2                | 32          | in     | 执行阶段流向访存阶段的要将数据加载到寄存器的编号 |
| mem_aluop              | 8           | out    | 访存阶段的alu操作码                              |
| mem_mem_addr           | 32          | out    | 访存阶段要方寸的虚拟地址                         |
| mem_reg2               | 32          | out    | 输出到访存阶段的要将数据加载到寄存器的编号       |
| ex_whilo               | 1           | in     | 执行阶段流向访存阶段是否要写hilo寄存器           |
| ex_hi                  | 32          | in     | 执行阶段要写的hi的值                             |
| ex_lo                  | 32          | in     | 执行阶段要写到lo的值                             |
| mem_whilo              | 1           | out    | 输出给mem是否要写到寄存器                        |
| mem_hi                 | 32          | out    | 输出到mem要写到hi寄存器的值                      |
| mem_lo                 | 32          | out    | 输出到mem要写到lo寄存器的值                      |
| ex_cp0_reg_we          | 1           | in     | 执行阶段是否要写cp0                              |
| ex_cp0_reg_write_addr  | 5           | in     | 执行阶段要写到cp0中寄存器的编号                  |
| ex_cp0_reg_data        | 32          | in     | 执行阶段要写到cp0中寄存器的值                    |
| mem_cp0_reg_we         | 1           | out    | 输出给mem是否要写cp0中的寄存器                   |
| mem_cp0_reg_write_addr | 5           | out    | 输出给mem要写到cp0中寄存器的编号                 |
| mem_cp0_reg_data       | 32          | out    | 输出到mem要写到cp0中寄存器的值                   |
| flush                  | 1           | in     | 输入是否要清空流水线                             |
| ex_excepttype          | 32          | in     | 执行阶段输出的异常的种类                         |
| ex_is_in_delayslot     | 1           | in     | 执行阶段的指令是否在延迟槽中                     |
| mem_excepttype         | 32          | out    | 输出到mem阶段的异常种类                          |
| mem_is_in_delayslot    | 1           | out    | 输出到mem阶段是否在延迟槽中                      |
| ex_pcFalse             | 1           | in     | ex阶段的pc指令是否正常                           |
| mem_pcFalse            | 1           | out    | 输出给mem的pc指令是否正常                        |
| mem_wd                 | 5           | out    | 输出给mem的寄存器的编号                          |
| mem_wreg               | 1           | out    | 输出给mem是否要写寄存器                          |
| mem_wdata              | 32          | out    | 输出给mem要写入寄存器的值                        |

* mem   
  * 该模块主要完成两部分，一部分是对前面阶段的异常信息进行综合，另外一部分是对load/store指令的存取使能信号、地址、字节选择信号和存取数据值的综合，以及包括对cp0寄存器和hilo寄存器值的传入。 

|        接口名         | 宽度（bit） | 输入/输出 |                   作用                    |
| :-------------------: | :---------: | :-------: | :---------------------------------------: |
|          rst          |      1      |    in     |                 复位信号                  |
|       mem_pc_i        |     32      |    in     |             来自访存阶段的pc              |
|       mem_pc_o        |     32      |    out    |            输出到写回阶段的pc             |
|         wd_i          |      5      |    in     |   访存阶段的指令要写入的目的寄存器地址    |
|        wreg_i         |      1      |    in     |       访存阶段是否要写入目的寄存器        |
|        wdata_i        |     32      |    in     |    访存阶段的指令要写入目的寄存器的值     |
|        aluop_i        |      8      |    in     |     访存阶段的指令要进行的运算子类型      |
|      mem_addr_i       |     32      |    in     | 访存阶段的加载，存储指令对应的存储器地址  |
|        reg2_i         |     32      |    in     |       访存阶段存储指令要存入的数据        |
|      mem_data_i       |     32      |    in     |          从数据存储器读取的数据           |
|      mem_addr_o       |     32      |    out    |          要访问的数据存储器地址           |
|       mem_we_o        |      1      |    out    |               是否是写操作                |
|       mem_sel_o       |      4      |    out    |               字节选择信号                |
|      mem_data_o       |     32      |    out    |          要写入数据存储器的数据           |
|       mem_ce_o        |      1      |    out    |            数据存储器使能信号             |
|        whilo_i        |      1      |    in     |       访存阶段是否要写入hilo寄存器        |
|         hi_i          |     32      |    in     |         访存阶段写入hi寄存器的值          |
|         lo_i          |     32      |    in     |         访存阶段写入lo寄存器的值          |
|     cp0_reg_we_i      |      1      |    in     |    访存阶段的指令是否要写入cp0中寄存器    |
| cp0_reg_write_addr_i  |      5      |    in     |   访存阶段的指令要写入cp0中寄存器的地址   |
|    cp0_reg_data_i     |     32      |    in     |   访存阶段的指令要写入cp0中寄存器的数据   |
|     cp0_reg_we_o      |      1      |    out    |  访存阶段的指令最终是否要写入cp0中寄存器  |
| cp0_reg_write_addr_o  |      5      |    out    | 访存阶段的指令zuiz要写入cp0中寄存器的地址 |
|    cp0_reg_data_o     |     32      |    out    | 访存阶段的指令最终要写入cp0中寄存器的数据 |
|     excepttype_i      |     32      |    in     |      译码，执行阶段收集到的异常信息       |
|   is_in_delayslot_i   |      1      |    in     |      访存阶段的指令是否是延迟槽指令       |
|     cp0_status_i      |     32      |    in     |           cp0中Status寄存器的值           |
|      cp0_cause_i      |     32      |    in     |           cp0中Cause寄存器的值            |
|       cp0_epc_i       |     32      |    in     |            cp0中epc寄存器的值             |
|     wb_cp0_reg_we     |      1      |    in     |     回写阶段的指令是否要写cp0中寄存器     |
| wb_cp0_reg_write_addr |      5      |    in     |     回写阶段的指令写cp0中寄存器的地址     |
|    wb_cp0_reg_data    |     32      |    in     |     回写阶段的指令写cp0中寄存器的数据     |
|     excepttype_o      |     32      |    out    |               最终异常类型                |
|       cp0_epc_o       |     32      |    out    |          cp0中epc寄存器的最新值           |
|   is_in_delayslot_o   |      1      |    out    |      访存阶段的指令是否是延迟槽指令       |
|       pcFalse_i       |      1      |    in     |            取指令地址是否异常             |
|      bad_addr_o       |     32      |    out    |           产生地址异常的虚地址            |
|         wd_o          |      5      |    out    | 访存阶段的指令最终要写入目的寄存器的地址  |
|        wreg_o         |      1      |    out    |   访存阶段指令是否有要写入的目的寄存器    |
|        wdata_o        |     32      |    out    | 访存阶段的指令最终要写入目的寄存器的数据  |
|        whilo_o        |      1      |    out    |    访存阶段指令最终是否要写hilo寄存器     |
|         hi_o          |     32      |    out    |     访存阶段指令最终要写hi寄存器的值      |
|         lo_o          |     32      |    out    |     访存阶段指令最终要写lo寄存器的值      |

* mem_wb   
  * 在该模块中，根据stall和flush信号值来决定是否将访存阶段的值传到写回阶段，当stall信号值判定暂停该阶段时，写回阶段的所有值都将保持不变；当flush为有效时，则给写回阶段传入0；当stall和flush都为无效时，则将访存阶段的所有值传到写回阶段。 

|         接口名         | 宽度（bit） | 输入/输出 |                   作用                   |
| :--------------------: | :---------: | :-------: | :--------------------------------------: |
|          clk           |      1      |    in     |                 时钟信号                 |
|          rst           |      1      |    in     |                 复位信号                 |
|      mem2wb_pc_i       |     32      |    in     |              来自访存阶段pc              |
|      mem2wb_pc_o       |     32      |    out    |                写回阶段pc                |
|         stall          |      6      |    in     |              流水线暂停信号              |
|         mem_wd         |      5      |    in     | 访存阶段的指令最终要写入的目的寄存器地址 |
|        mem_wreg        |      1      |    in     |  访存阶段的指令最终是否要写入目的寄存器  |
|       mem_wdata        |     32      |    in     |    访存阶段指令最终写入的目的寄存器值    |
|       mem_whilo        |      1      |    in     |   访存阶段的指令是否要写进HI LO寄存器    |
|         mem_hi         |     32      |    in     |     访存阶段的指令要写入hi寄存器的值     |
|         mem_lo         |     32      |    in     |     访存阶段的指令要写入lo寄存器的值     |
|        wb_whilo        |      1      |    out    |    回写阶段的指令是否要写hi lo寄存器     |
|         wb_hi          |     32      |    out    |    回写阶段的指令要写入hi 寄存器的值     |
|         wb_lo          |     32      |    out    |    回写阶段的指令要写入lo 寄存器的值     |
|     mem_cp0_reg_we     |      1      |    in     |   访存阶段的指令是否要写进CP0中寄存器    |
| mem_cp0_reg_write_addr |      5      |    in     |  访存阶段的指令要写进CP0中寄存器的地址   |
|    mem_cp0_reg_data    |     32      |    in     |   访存阶段的指令要写进CP0中寄存器的值    |
| wb_cp0_reg_write_addr  |      5      |    out    |  回写阶段的指令要写进CP0中寄存器的地址   |
|    wb_cp0_reg_data     |     32      |    out    |   回写阶段的指令要写进CP0中寄存器的值    |
|     wb_cp0_reg_we      |      1      |    out    |   回写阶段的指令是否要写进CP0中寄存器    |
|         flush          |      1      |    in     |              是否清除流水线              |
|         wb_wd          |      5      |    out    |   回写阶段的指令要写入的目的寄存器地址   |
|        wb_wreg         |      1      |    out    |    回写阶段的指令是否要写入目的寄存器    |
|        wb_wdata        |     32      |    out    |      回写阶段指令写入的目的寄存器值      |

* cp0_reg   
  * 依据写入地址将输入数据保存到不同的寄存器中，后面部分实现对CP0中寄存器的读操作，依据读取地址，将相应寄存器的值通过data_o接口输出。

|      接口名       | 宽度（bit） | 输入/输出 |              作用              |
| :---------------: | :---------: | :-------: | :----------------------------: |
|        clk        |      1      |    in     |            时钟信号            |
|        rst        |      1      |    in     |            复位信号            |
|       we_i        |      1      |    in     |      是否要写入CP0寄存器       |
|      waddr_i      |      5      |    in     |     要写的CP0寄存器的地址      |
|      raddr_i      |      5      |    in     |     要读取CP0寄存器的地址      |
|      data_i       |     32      |    in     |     要写的CP0寄存器的数据      |
|   excepttype_i    |     32      |    in     |          最终异常类型          |
|     cp0_pc_i      |     32      |    in     |       发生异常的指令地址       |
| is_in_delavslot_i |      1      |    in     | 发生异常的指令是否是延迟槽指令 |
|       int_i       |      6      |    in     |      6个外部硬件中断输入       |
|      data_o       |     32      |    out    |    读取的CP0中某寄存器的值     |
|      count_o      |     32      |    out    |        Count寄存器的值         |
|     compare_o     |     32      |    out    |       Compare寄存器的值        |
|     status_o      |     32      |    out    |        Status寄存器的值        |
|      cause_o      |     32      |    out    |        Cause寄存器的值         |
|       epc_o       |     32      |    out    |         EPC寄存器的值          |
|     config_o      |     32      |    out    |        Config寄存器的值        |
|      prid_o       |     32      |    out    |          PRId寄存器值          |
|    bad_addr_i     |     32      |    in     |     产生数据读写异常的地址     |
|     badvaddr      |     32      |    out    |        触发例外的虚地址        |
|    timer_int_o    |      1      |    out    |       是否有定时中断发生       |

* hilo  在时钟上升沿，如果rst信号无效，那么就判断写使能信号we是否为1，如果是1，那么就将输入的hi_i，lo_i的值作为HI，LO寄存器的新值，并通过hi_o，lo_o接口输出。

| 接口名 | 宽度（bit） | 输入/输出 |          作用          |
| :----: | :---------: | :-------: | :--------------------: |
|  rst   |      1      |    in     |        复位信号        |
|  clk   |      1      |    in     |        时钟信号        |
|   we   |      1      |    in     | Hi、Lo寄存器写使能信号 |
|  hi_i  |     32      |    in     |   要写入Hi寄存器的值   |
|  ho_i  |     32      |    in     |   要写入LO寄存器的值   |
|  hi_o  |     32      |    out    |      HI寄存器的值      |
|  lo_o  |     32      |    out    |      LO寄存器的值      |

* ctrl  
  * 接受某些模块发出的暂停请求信号，包括译码阶段的load相关、执行阶段的乘除法、异常指令、epc寄存器以及来自Axi的暂停请求信号。在ctrl内部实现中，会根据接收到的不同暂停请求，给stall赋值，已实现对五级流水线不同阶段的暂停，当需要处理异常时，还会将flush信号置为有效，清除流水线。 

|      接口名      | 宽度（bit） | 输入/输出 |                   作用                   |
| :--------------: | :---------: | :-------: | :--------------------------------------: |
|       rst        |      1      |    in     |                 复位信号                 |
|       clk        |      1      |    in     |                 时钟信号                 |
| stallreq_from_id |      1      |    in     | 处于译码阶段的指令是否请求流水线暂停信号 |
| stallreq_from_ex |      1      |    in     | 处于执行阶段的指令是否请求流水线暂停信号 |
|   excepttype_i   |     32      |    in     |            综合过后的异常类型            |
|    cp0_epc_i     |     32      |    in     |              EPC寄存器的值               |
|     stall_i      |      1      |    in     |          来自Axi接口的暂停信号           |
|      new_pc      |     32      |    out    |             异常处理入口地址             |
|      flush       |      1      |    out    |              是否清除流水线              |
|      stall       |      6      |    out    |            暂停流水线控制信号            |



#### 3. 设计过程

**3.1 设计流水账**

* 第17周

  * 12.21，星期一， 小组成员集结完毕，三个人同时陷入迷茫，不知如何下手，看群里发的吕学长的视频。
  * 12.23 ，星期二，翻文档，看各种实验要求文档，ppt，学长视频，GitHub，确定具体实验要求，试着确定如何下手。在下午的时候，胡卫同学在看了《自己动手写CPU》.(雷思磊)，觉得这本书写的很不错，提出，可以按照这本书提供的思路完成实验。随后一致同意，就开始看书。
  * 12.24~12.27，所有组员先看《自己动手写CPU》.(雷思磊)这本书，遇到疑问就提出，互相解答，实在不行问学长。
* 第18周

  * 12.28 ，星期一，计划先实现基本的52条指令，其中赵雪松同学负责添加逻辑运算指令以及移位指令，胡卫同学负责数据移动指令以及算术运算指令，刘玉莽同学负责分支跳转指令以及访存指令。然后就开始我们的各自工作。这一天结束后，我们都还没有完成各自的工作。
  * 12.29，星期二，小组成员继续完成各自的工作，赵雪松在这一天完成了逻辑运算指令，于是我们仿照书上的工作，建立了相应的spoc，测试逻辑运算指令是否有效，期间有一些bug，由胡卫和刘玉莽共同调试。记录错误以及解决过程。
  * 12.30，星期三，胡卫，刘玉莽分别完成了数据移动指令和分支跳转指令，当然还是有bug，胡卫与刘玉莽一起debug。赵雪松继续完善相应的指令。记录错误以及解决过程。
  * 12.31，星期四，赵雪松完成了移位指令并进行了移位指令的测试。胡卫，刘玉莽分别完成了算术运算指令和访存指令，胡卫与刘玉莽一起debug。记录错误以及解决过程。
  * 1.1， 星期五，至此，52条指令一斤完成，也都通过了6类指令的独立测试，于是由小组成员赵雪松利用visio画出初步的数据通路图，由胡卫和刘玉莽负责将我们写的cpu（openmips）封装成sram接口，基于提供的trace进行测试，在测试的过程，曾几度怀疑我们到底通没通过独立测试，因为一把这个52条指令综合起来，测试的时候不断地出来bug，有的时候就是感觉应该没问题，然而就是不正确，就是这个52条bug找了一天。记录错误以及解决过程。
  * 1.2，星期六，赵雪松继续完善数据通路图，胡卫以及刘玉莽开始看特权指令以及内陷指令，因为这个指令涉及到协处理器cp0，所以需要先处理cp0寄存器，虽然已经给了参考代码，但是要完成特权指令以及内陷指令，必须要把这个搞懂，我们两个人就先把mtc0以及mfc0指令完成。同时在这一天赵雪松也已经把52条指令地数据通路图完成。
  * 1.3，星期天，我们小组成员三个人一起处理剩余的中断，地址错例外，系统调用例外，断点例，保留指令例外算术溢出例外，并且在这一天完成了指令的编码。
  * 1.4，星期一，至此57条指令已经初步添加完成，小组三个人一起进行57条指令的功能测试，这测出的错都是关于mfc0以及mtc0的，也就是内陷特权指令相关的，花了一整天时间去debug，但是在最后一点儿的功能测试点还是卡住了。记录错误以及解决过程。
* 第19周
  * 1.5，星期二，赵雪松开始完善添加了cp0的数据通路图，胡卫负责将cpu封装成axi接口，刘玉莽负责最后阶段的debug工作。后面尝试a4ddr下的工程，打算下板，但是综合不成功，由于时间紧迫，且鉴于下板调试信息不足，就放弃了下板。记录错误以及解决过程。
  * 1.6，星期三，小组成员一起进行连接了axi的功能测试，期间遇到了一些很难的bug，找其他同学寻求了帮助。记录错误以及解决过程。
  * 1.7，星期四，对于连接了axi的MIPS core，我们起初加入了两路组相联的cache，但是测试一直有bug，于是我们将两路组相联的cache替换为写直达的cache，一起开始开始debug，搞了很久，之后通过，于是在晚上的时候进行连接了axi接口且有写直达cache的cpu的性能测试，全部通过。鉴于面明天（1.8）就要进行检查，我们就开始做准备工作。记录错误以及解决过程。
  * 1.8，星期五，进行三个礼拜实验成果的检查，顺利完成了现场添加指令（abs），现场答辩，老师提问环节，开始准备实验报告，以及提交材料。

**3.2 错误记录**

**1. 六类指令独立测试**

1.  Hilo寄存器的相关指令mfhi，mflo他们读的数据是Hilo寄存器中读出来的然后写到rs的，这两条指令没有问题，但是mthi，mtlo这两条指令要想Hilo寄存器写，就感觉不知道如何处理。

   最后又仔细看数据通路图，发现ex阶段是有一个输出信号用来判断是否向Hilo寄存器写数据的，

![image-20201230130003091](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201230130003091.png)

​		只要要写寄存器的时候像将whilo_o信号置位1即可

2. 对于Hilo寄存器的操作这里有一些问题![image-20201230165740209](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201230165740209.png)

   * 这里是mfhi指令，说明mfhi指令的实现有误，最后发现是`define EXE_RES_SHIFT 3'b010 与宏定义 `define EXE_RES_HILO 3'b010 重复，导致出现二义性。

3. I型指令容易忘记对立即数进行赋值和改变写寄存器号。

4. 在实现div和divu指令时，出现了一个问题，这个问题是由流水线暂停不成功引起的，如下：

   * ![image-20210101170220795](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210101170220795.png)

   * 暂停请求已发出，pc也跟着暂停了，但是取指令操作依然没有暂停，而是等到了下一个周期才暂停。

   * 原始关于更新pc的代码块

   * ```verilog
     always @ (posedge clk) begin  
     		if (ce == `ChipDisable) begin
     			pc <= 32'h00000000;
     		end else if(stall[0] == 0) begin
     		  		pc <= pc + 4'h4;
     		end
     	end
     ```

   * D触发器原理，clk控制的，时钟上升沿的时候stall变为1，读到的还是0，更新代码如下

   * ```verilog
     always @ (negedge clk) begin  // 重要的事情说三遍,这里要改为下降沿!!!
     		if (ce == `ChipDisable) begin
     			pc <= 32'h00000000;
     		end else if(stall[0] == 0) begin
     		  		pc <= pc + 4'h4;
     		end
     	end
     ```

   * 解决

5. ip核这里用生成用的自己又勾选了这个选项![image-20210102002711423](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210102002711423.png)

   * 造成后面pc错位，重新将ip核去掉这个选项.

6. 对于分支指令，在译码时忘了需要有判断条件，直接照着无条件判断做的，造成一些错误。

7. 在验证取指译码阶段的时候，查看要写回的数据，发现第一条指令的写回数据要提前一个周期，其他指令均正常，如下：

   * ![image-20210103151833762](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210103151833762.png)
   * 后面发现是由于第一个指令在译圈起来的部分占据两个周期，所以他在这里就有两个执行阶段.

**2. 五十二条指令测试**

1. 测试文件中resetn要取反调用

2. 利用将已经完成的openmips放到测试文件进行测试，出现pc不对齐的情况，

   * 解决方法，如下，方框框起来的部分要与椭圆圈起来的部分pc的上升沿和下降沿要区分开来，修改regfile的改变信号为下降沿，将pc_reg.v的时钟控制信号改回上升沿，同时在调用openmips.v的soc_lite_top.v里，给openmips 输入时钟信号取反（由于数据存储器和指令存储器都是在soc_lite_top中被调用），这样的话指令存储器，数据存储器，寄存器堆的信号就都是上升沿控制。

   * ![image-20210103193654731](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210103193654731.png)

     * regfile.v主要修改

     * ```verilog
       always @ (negedge clk) begin  // 这里要修改为下降沿，相当于模块内与模块间的时钟沿要错开
       		if (rst == `RstDisable) begin
       			if((we == `WriteEnable) && (waddr != `RegNumLog2'h0)) begin
       				regs[waddr] <= wdata;
       			end
       		end
       	end
       ```

     * pc_reg.v主要修改

     * ```verilog
       always @ (posedge clk) begin  // 
       		if (ce == `ChipDisable) begin
       			pc <= 32'hbfc0_0000;
       		end else if(stall[0] == 0) begin
       			if (branch_flag_i == 1'b1) begin
       				pc <= branch_target_address_i;
       			end else begin
       				pc <= pc + 4'h4;
       			end
       		end 
       	en
       ```

   

3. 控制台报错如下：

   * ```assembly
     Test begin!
     --------------------------------------------------------------
     [   2317 ns] Error!!!
         reference: PC = 0x9fc06b50, wb_rf_wnum = 0x10, wb_rf_wdata = 0x00000001
         mycpu    : PC = 0x0fc06b50, wb_rf_wnum = 0x10, wb_rf_wdata = 0x00000001
     --------------------------------------------------------------
     $finish called at time : 2357 ns : File "D:/practice_code/subject/hardware_design/soc_sram_func/testbench/mycpu_tb.v" Line 160
     
     ```

   * 报错指令`bfc00704:	0ff01ad4 	jal	bfc06b50 <n1_lui_test>`

   * 返回查看

     * ![image-20210103201809398](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210103201809398.png)

   * 原因，`branch_target_address_o`返回地址没有pc+4.

   * 修改过后，依然报和上面一样的错，进入id.v中继续找，终于找到了错误原因。现在的`branch_target_address_o <= {pc_plus_4[31:28], imm_sll2_signedext_j};`而定义的imm_sll2_signedext_j是这样的wire[ \`RegBus] imm_sll2_signedext_j; 定义的是32位，重新修改`branch_target_address_o <= {pc_plus_4[31:28], imm_sll2_signedext_j[27:0]};`

4. 控制台报错如下：

   * ```assembly
     ==============================================================
     Test begin!
     ----[  14025 ns] Number 8'd01 Functional Test Point PASS!!!
     --------------------------------------------------------------
     [  14117 ns] Error!!!
         reference: PC = 0x9fc00abc, wb_rf_wnum = 0x0a, wb_rf_wdata = 0x00000000
         mycpu    : PC = 0x9fc00abc, wb_rf_wnum = 0x0a, wb_rf_wdata = 0xbfafaaaa
     --------------------------------------------------------------
     ```

   * 出错指令如下：

     * ```assembly
       bfc00ab0:	3508f02c 	ori	t0,t0,0xf02c
       /home/ghj/Desktop/func/start.S:537
       bfc00ab4:	3409aaaa 	li	t1,0xaaaa
       /home/ghj/Desktop/func/start.S:540
       bfc00ab8:	8d0a0000 	lw	t2,0(t0)
       /home/ghj/Desktop/func/start.S:541
       bfc00abc:	01495026 	xor	t2,t2,t1
       ```

   * ![image-20210103231946263](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210103231946263.png)

   * 写得都正确，说明lw数据前推有问题。检查id.v，最后发现是lw指令的暂停请求没有发出来，因为参照书上写的，他的暂停是后面加上的。将`assign stallreq = 0; //这里暂时没有暂停请求`注释掉。

5. 控制台报错如下：

   * ```assembly
     --------------------------------------------------------------
     [ 105257 ns] Error!!!
         reference: PC = 0xbfc35f44, wb_rf_wnum = 0x02, wb_rf_wdata = 0xc822c7e8
         mycpu    : PC = 0xbfc35f44, wb_rf_wnum = 0x02, wb_rf_wdata = 0x800d34b8
     --------------------------------------------------------------
     ```

   * ![image-20210104133212147](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210104133212147.png)

   * 猜测是没存进去或者是没取出来，后面请教学长才发现当要读的时候wen要置为全0，这个问题的主要是字节选择信号哪里给的是全1.

   * ![image-20210104133456166](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210104133456166.png)

   * 将所有要读的数据这里的`mem_sel_o`全置为0，这个测试点通过。

6. 控制台报错如下

   * ```assembly
     --------------------------------------------------------------
     [ 237727 ns] Error!!!
         reference: PC = 0xbfc28f48, wb_rf_wnum = 0x02, wb_rf_wdata = 0x42ea0000
         mycpu    : PC = 0x8fc28f48, wb_rf_wnum = 0x02, wb_rf_wdata = 0x42ea0000
     --------------------------------------------------------------
     ```

   * ![image-20210104151029095](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210104151029095.png)

   * 翻id.v的代码，发现是没有定义pc_plus8，修改之后通过`soft/func_part/obj_1/inst_rom.coe`，其中trace对比文件位于`cpu132_gettrace/goden_trace.txt`.

**3. 五十七条指令测试（加入特权内陷指令）**

1. 控制台报错如下

   * ```assembly
     ==============================================================
     Test begin!
     --------------------------------------------------------------
     [   2087 ns] Error!!!
         reference: PC = 0xbfc00000, wb_rf_wnum = 0x08, wb_rf_wdata = 0xffffffff
         mycpu    : PC = 0xbfc00380, wb_rf_wnum = 0x1a, wb_rf_wdata = 0x00000000
     --------------------------------------------------------------
     ```

     

   * ![image-20210105174559232](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210105174559232.png)

   * 原因是空指令错设置为非法指令，id.v修改如下

   * ```verilog
     instvalid <= (inst_i == `ZeroWord) ? `InstValid :`InstInvalid;	   // 空指令默认为有效指令
     ```

2. 控制台报错如下

   * ```assembly
     --------------------------------------------------------------
     [  14427 ns] Error!!!
         reference: PC = 0xbfc04a64, wb_rf_wnum = 0x17, wb_rf_wdata = 0x00400000
         mycpu    : PC = 0xbfc00380, wb_rf_wnum = 0x1a, wb_rf_wdata = 0x00000000
     --------------------------------------------------------------
     ```

   * ![image-20210105183141350](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210105183141350.png)

   * 提示mtc0是无效指令，后来发现是把mtc指令单个在另一个always模块，导致出错，修改即可。

3. 控制台报错如下

   * ```assembly
     [  15067 ns] Error!!!
         reference: PC = 0xbfc003f4, wb_rf_wnum = 0x1a, wb_rf_wdata = 0xbfc04a9c
         mycpu    : PC = 0xbfc003f4, wb_rf_wnum = 0x1a, wb_rf_wdata = 0x00000000
     ```

   * ![image-20210106002027943](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210106002027943.png)

   * ```verilog
     end else if(aluop_i == `EXE_MFC0_OP) begin  
     			// cp0_reg_read_addr_o <= inst_i[15:11];
     			// Hilores      <= cp0_reg_data_i; 
     			if(mem_cp0_reg_we && (mem_cp0_reg_write_addr == inst_i[15:11]) ) begin  // 这个地方一定要注意顺序(mem阶段的才是最新的)
     				cp0_reg_read_addr_o <= inst_i[15:11];
     				Hilores             <= mem_cp0_reg_data;
     			end else if (wb_cp0_reg_we && (wb_cp0_reg_write_addr == inst_i[15:11]) ) begin
     				cp0_reg_read_addr_o <= inst_i[15:11];
     				Hilores      <= wb_cp0_reg_data;
     			end else begin
     				cp0_reg_read_addr_o <= inst_i[15:11];
     				Hilores      <= cp0_reg_data_i;
     			end
     ```

   * 按理说Hilores应该为cp0_reg_data_i， 但是这里即使前两个条件不满足，这里也是0，最后找了好久，发现另有一个always模块是这样写的。

   * ```verilog
     always @ (*) begin
     	...
         default:				begin
        	 Hilores <= `ZeroWord;  // 这
         end
         ...
     end
     ```

   * 这个default真的是……

4. 控制台报错如下

   * ```assembly
     --------------------------------------------------------------
     [  40897 ns] Error!!!
         reference: PC = 0xbfc00380, wb_rf_wnum = 0x1a, wb_rf_wdata = 0x00018027
         mycpu    : PC = 0xbfc029cc, wb_rf_wnum = 0x02, wb_rf_wdata = 0x00000000
     --------------------------------------------------------------
     ```

   * mem_wb.v中的flush信号没连上线。找了半天，到最后发现cp0协处理器没有定义关于badaddr的寄存器（因为书上没有讲到这个，而测试点又有这个），定义这个寄存器，通过。

5. 控制台报错如下

   * ![image-20210106195604002](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210106195604002.png)

   * ![image-20210106195647978](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210106195647978.png)

   * 从epc中读入数据，其中是延迟槽指令的地址，可以看到两个相差4，找了半天，最后发现对应的分支跳转指令是有条件跳转（beqz），实际上这条指令不满足跳转，但是在《自己动手写CPU》的书中，对于延迟槽指令，他的定义是只有跳转发生后面才是……后面我们将延迟槽指令改为只要该指令是分支跳转指令，不管发不发生跳转，后面的指令都定义为延迟槽指令，即：

     * ```verilog
       `EXE_BEQ:			begin
           wreg_o <= `WriteDisable;		aluop_o <= `EXE_BEQ_OP;
           alusel_o <= `EXE_RES_JUMP_BRANCH; reg1_read_o <= 1'b1;	reg2_read_o 	<= 1'b1;
           instvalid <= `InstValid;	
           next_inst_in_delayslot_o <= `InDelaySlot;
           if(reg1_o == reg2_o) begin
               branch_target_address_o <= pc_plus_4+ imm_sll2_signedext_b;
               branch_flag_o <= `Branch;
               // next_inst_in_delayslot_o <= `InDelaySlot;		  	
           end
       end
       ```

   * 测试通过。

**4. 测试full**

1. 控制台报错如下

   * ```assembly
     --------------------------------------------------------------
     [1303277 ns] Error!!!
         reference: PC = 0xbfc2e240, wb_rf_wnum = 0x02, wb_rf_wdata = 0x00002560
         mycpu    : PC = 0xbfc00380, wb_rf_wnum = 0x1a, wb_rf_wdata = 0x00004000
     --------------------------------------------------------------
     ```

   * ![image-20210106203526076](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210106203526076.png)

   * 对比报错pc，可以看到本来不应该触发异常，但是这里却触发了异常，查看ex.v中的lh地址例外判断，修改如下

   * ```verilog
     `EXE_LH_OP, `EXE_LHU_OP: begin
         // if (mem_addr_o[1:0]!=2'b00 || mem_addr_o[1:0]!=2'b10) begin
         if (mem_addr_o[1:0]!=2'b00 && mem_addr_o[1:0]!=2'b10) begin
         	badaddr_read_fetch <= 1; 
         end
     end
     ```

   * 通过test_full.

**5. 加入axi，cache测试**

1. 控制台报错如下

   * ```cassandra
     ----[28849105 ns] Number 8'd58 Functional Test Point PASS!!!
             [28852000 ns] Test is running, debug_wb_pc = 0x00000000
     --------------------------------------------------------------
     [28856209 ns] Error!!!
         reference: PC = 0xbfc371a4, wb_rf_wnum = 0x05, wb_rf_wdata = 0x800d6764
         mycpu    : PC = 0xbfc371a4, wb_rf_wnum = 0x05, wb_rf_wdata = 0xc83b0be0
     --------------------------------------------------------------
     ```

   * ![image-20210107181358081](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210107181358081.png)

   * 猜测是load的stall没有暂停住

   * 原来的发出暂停的关键代码如下

   * ```verilog
     assign longest_stall = stallreq_from_ex_i || stallreq_from_id_i;
     ```

   * 将代码修改如下

   * ```verilog
     assign longest_stall = |stall;
     ```

   至此加入axi，cache测试的功能测试以及性能测试均通过。



#### 4 设计结果

​	具体代码以及以及上传到对应目录文件下，这里仅提供一些关键代码！

**4.1** **设计交付物说明**

1. `cache_lab_v0.06` 计算机体系结构实验二所发的源码（需要自己实现cache）

2. **只实现到没有异常处理的openmips（`mycpu`）**

   2.1 **测试目录**

   ​	`my_cpu/my_cpu.xpr`

   2.2 **源代码**

   ​	`my_cpu/source/code`

   2.3 **ip**

   ​	`my_cpu/source/ip`

   2.4 **功能测试**

   ​	 `hardware_design/my_cpu/source/coe`以及	`					 		hardware_design/my_cpu/source/funcTest_indepent`

3. `cpu132_gettrace`, goden_trace文件所在目录（`soc_sram_func\testbench\mycpu_tb.v`要用到）

4. `shiyan4`，计算机组成原理实验4（流水线，十条指令）。

5. **实现了57条指令的openmips(`soc_sram_func`)**

   5.1 **工程目录**

   ​	`soc_sram_func/run_vivado/mycpu_prj1/mycpu.xpr"`

   5.2  **源代码**

   ​	`soc_sram_func/rtl/myCPU`

6. `soft`， 里面是测试指令目录

7. `axi`, axi连线以及cache。

8. `test_on_site`, 现场添加指令说明。

9. `实验结果`， 过程记录。

**4.2** **设计演示结果**

**逻辑运算指令**

* ![image-20201229231455396](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201229231455396.png)

* 测试文件"my_cpu\source\funcTest_independent\LogicInstTest\logic.coe"
* 测试结果
  * ![image-20201230204728831](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201230204728831.png)
  * ![image-20201230210702343](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201230210702343.png)
* 结果正确

**移位指令**

* ![image-20201229231455396](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201229231455396.png)

* 其中算术右移指令sra的实现如下

  * ```verilog
    `EXE_SRA_OP:			begin
        shiftres <= ($signed(reg2_i)) >>> reg1_i[4:0];
    end
    ```

  * 直接采用Verilog的有符号算数运算，其中要`$signed(reg2_i)`首先将数据转换为有符号数。

* 进行测试，测试文件"my_cpu\source\funcTest_independent\ShiftInstTest\shift.coe"

* 测试结果

  * ![image-20201230215503867](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201230215503867.png)

* 结果正确

**数据移动指令**

* ![image-20201230023350085](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201230023350085.png)
* 测试文件"my_cpu\source\funcTest_independent\ShiftInstTest\shift.coe"
* 测试结果
  * ![image-20201230233041081](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201230233041081.png)
  * ![image-20201230234708052](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201230234708052.png)
  * 时序图说明，这里着重看寄存器$4，hi寄存器和lo寄存器。其中32个寄存器的值都是写回阶段完成之后的值，而hi寄存器和lo寄存器，对应的结果都是访存阶段结束的值，所以这也就是为什么最后两条指令中lo寄存器的值与寄存器\$4的值中间会隔开一个周期，尽管他们是紧邻的两个指令。
* 测试成功

**算术运算指令**

* ![image-20201230203024866](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201230203024866.png)
* 测试文件"my_cpu\source\funcTest_independent\ArithmeticTest\arithmetic.coe"
* 测试结果
  * `add\addi\addiu\addu\sub\subu`
    * ![image-20210101192019719](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210101192019719.png)
    * ![image-20210101192237800](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210101192237800.png)
  * `slt\sltu\slti\sltiu`
    * ![image-20210101192432268](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210101192432268.png)
  * `mult\multu `
    * ![image-20210101192643150](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210101192643150.png)
  * `div\divu`
    * ![image-20210101192900252](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210101192900252.png)
* 结果正确

**分支跳转指令**

* ![image-20210101201703574](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210101201703574.png)
* 测试数据1“"my_cpu\source\coe\J_BTest\Test1\branch.coe"”（自己动手写cpu）.
* 波形图

  * ![image-20210102172300966](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210102172300966.png)
  * ![image-20210102172420764](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210102172420764.png)
  * ![image-20210102172541481](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210102172541481.png)

* 测试正确

**分支指令**

* 测试数据测试数据1"my_cpu\source\funcTest_independent\J_BTest\Test2\B.coe"

* 波形图
  * ![image-20210102203319155](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210102203319155.png)
  * ![image-20210102203922223](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210102203922223.png)

* 测试正确

**访存指令**

* ![image-20210102205428342](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210102205428342.png)

* 测试数据"my_cpu\source\funcTest_independent\J_BTest\Test2\B.coe"

* 波形图

  * ![image-20210103151311193](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210103151311193.png)
  * ![image-20210103151415411](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210103151415411.png)

* 结果正确



**内陷指令以及特权指令**

* ![image-20210104165736229](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210104165736229.png)

**52条指令测试结果**

***

1. **`soft/func_part/obj_1/inst_rom.coe`测试**

   1. ![image-20210106223951766](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210106223951766.png)

      

2. **`soft/func_part/obj_2/inst_rom.coe`测试**

   1. ![image-20210104162330554](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210104162330554.png)
   2. ![image-20210104162400373](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210104162400373.png)
   3. 通过



**57条指令**

1. 精确异常的实现

   * ```verilog
     //写使能信号 在always里面 
     	reg mem_we;
     	assign mem_we_o = mem_we & (~(|excepttype_o)) ; // 这里再加入了异常处理之后需要增强判断条件(精确异常)
     
     	//这里再加入了异常处理之后需要增强判断条件(精确异常)
     	//改sel
     	always @(*) begin
     		if((|excepttype_o)==1) begin
     			mem_sel_o <= 4'b0000;
     		end
     		else begin
     			mem_sel_o <= mem_sel_o;
     		end
     	end
     ```

2. 地址例外（读数据以及取指），情况下存储读数据地址还是取值地址的判断

   * ```verilog
     // 地址例外
     always @ (*) begin
         if(rst == `RstEnable) begin
             badaddr_read_fetch <= 0;
             badaddr_write <= 0;
             pcFalse_o       <= 0;
         end else begin
             badaddr_read_fetch <= 0;
             badaddr_write <= 0;
             pcFalse_o       <= 0;
             case (aluop_i)
                 `EXE_LW_OP: begin
                     if (mem_addr_o[1:0]!=2'b00) begin
                         badaddr_read_fetch <= 1; 
                     end
                 end
                 `EXE_LH_OP, `EXE_LHU_OP: begin
                     if (mem_addr_o[1:0]!=2'b00 && 										mem_addr_o[1:0]!=2'b10) begin
                         badaddr_read_fetch <= 1; 
                     end
                 end
                 `EXE_SW_OP: begin
                     if (mem_addr_o[1:0]!=2'b00) begin
                         badaddr_write <= 1; 
                     end
                 end
                 `EXE_SH_OP: begin
                     if (mem_addr_o[1:0]!=2'b00 && 				  						mem_addr_o[1:0]!=2'b10) begin
                         badaddr_write <= 1; 
                     end
                 end
                 default: begin
                 end 
             endcase
             if (ex_pc_o[1:0]!=2'b00) begin // pc
                 badaddr_read_fetch <= 1; 
                 pcFalse_o            <= 1;
             end 
         end
     end
     ```

   * 增加pcFalse_o，如果为真表明是取值错误。

3. **`soft/func_part/obj_3/inst_rom.coe`测试**

   * ```assembly
     ==============================================================
     Test begin!
     ----[  14025 ns] Number 8'd01 Functional Test Point PASS!!!
     ----[  18675 ns] Number 8'd02 Functional Test Point PASS!!!
             [  22000 ns] Test is running, debug_wb_pc = 0xbfc00388
     ----[  23495 ns] Number 8'd03 Functional Test Point PASS!!!
     ----[  29155 ns] Number 8'd04 Functional Test Point PASS!!!
             [  32000 ns] Test is running, debug_wb_pc = 0xbfc00390
     ----[  34725 ns] Number 8'd05 Functional Test Point PASS!!!
     ----[  40385 ns] Number 8'd06 Functional Test Point PASS!!!
             [  42000 ns] Test is running, debug_wb_pc = 0xbfc00678
     ----[  46735 ns] Number 8'd07 Functional Test Point PASS!!!
             [  52000 ns] Test is running, debug_wb_pc = 0xbfc004c8
     ----[  53105 ns] Number 8'd08 Functional Test Point PASS!!!
     ----[  59455 ns] Number 8'd09 Functional Test Point PASS!!!
             [  62000 ns] Test is running, debug_wb_pc = 0xbfc0038c
     ----[  66095 ns] Number 8'd10 Functional Test Point PASS!!!
             [  72000 ns] Test is running, debug_wb_pc = 0xbfc049ec
     ----[  72735 ns] Number 8'd11 Functional Test Point PASS!!!
     ----[  79245 ns] Number 8'd12 Functional Test Point PASS!!!
             [  82000 ns] Test is running, debug_wb_pc = 0xbfc00a38
     ----[  85155 ns] Number 8'd13 Functional Test Point PASS!!!
             [  92000 ns] Test is running, debug_wb_pc = 0xbfc03ec4
     ----[  92925 ns] Number 8'd14 Functional Test Point PASS!!!
             [ 102000 ns] Test is running, debug_wb_pc = 0xbfc0068c
     ----[ 106645 ns] Number 8'd15 Functional Test Point PASS!!!
             [ 112000 ns] Test is running, debug_wb_pc = 0x00000000
     ----[ 120365 ns] Number 8'd16 Functional Test Point PASS!!!
             [ 122000 ns] Test is running, debug_wb_pc = 0xbfc00450
             [ 132000 ns] Test is running, debug_wb_pc = 0x00000000
     ----[ 134085 ns] Number 8'd17 Functional Test Point PASS!!!
             [ 142000 ns] Test is running, debug_wb_pc = 0x00000000
     ----[ 147805 ns] Number 8'd18 Functional Test Point PASS!!!
             [ 152000 ns] Test is running, debug_wb_pc = 0xbfc04564
     ----[ 161525 ns] Number 8'd19 Functional Test Point PASS!!!
             [ 162000 ns] Test is running, debug_wb_pc = 0xbfc0038c
             [ 172000 ns] Test is running, debug_wb_pc = 0x00000000
     ----[ 175245 ns] Number 8'd20 Functional Test Point PASS!!!
             [ 182000 ns] Test is running, debug_wb_pc = 0xbfc004bc
     ----[ 188975 ns] Number 8'd21 Functional Test Point PASS!!!
             [ 192000 ns] Test is running, debug_wb_pc = 0x00000000
             [ 202000 ns] Test is running, debug_wb_pc = 0xbfc04e5c
     ----[ 202715 ns] Number 8'd22 Functional Test Point PASS!!!
             [ 212000 ns] Test is running, debug_wb_pc = 0x00000000
     ----[ 216445 ns] Number 8'd23 Functional Test Point PASS!!!
             [ 222000 ns] Test is running, debug_wb_pc = 0xbfc00478
     ----[ 230175 ns] Number 8'd24 Functional Test Point PASS!!!
             [ 232000 ns] Test is running, debug_wb_pc = 0xbfc00698
             [ 242000 ns] Test is running, debug_wb_pc = 0xbfc00398
     ----[ 243905 ns] Number 8'd25 Functional Test Point PASS!!!
             [ 252000 ns] Test is running, debug_wb_pc = 0x00000000
     ----[ 257635 ns] Number 8'd26 Functional Test Point PASS!!!
     ==============================================================
     Test end!
     ----PASS!!!
     $finish called at time : 258285 ns : File "D:/practice_code/subject/hardware_design/soc_sram_func/testbench/mycpu_tb.v" Line 261
     
     ```

   * 通过。

4. **`soft/func_full/obj/inst_rom.coe`测试**

   * ```assembly
     ==============================================================
     Test begin!
     ----[  14025 ns] Number 8'd01 Functional Test Point PASS!!!
             [  22000 ns] Test is running, debug_wb_pc = 0xbfc5e4d4
             [  32000 ns] Test is running, debug_wb_pc = 0xbfc5f474
     ----[  40475 ns] Number 8'd02 Functional Test Point PASS!!!
             [  42000 ns] Test is running, debug_wb_pc = 0xbfc89440
     ----[  49355 ns] Number 8'd03 Functional Test Point PASS!!!
             [  52000 ns] Test is running, debug_wb_pc = 0xbfc3ad58
             [  62000 ns] Test is running, debug_wb_pc = 0xbfc3c260
     ----[  71115 ns] Number 8'd04 Functional Test Point PASS!!!
             [  72000 ns] Test is running, debug_wb_pc = 0xbfc23898
             [  82000 ns] Test is running, debug_wb_pc = 0xbfc24c40
             [  92000 ns] Test is running, debug_wb_pc = 0xbfc2621c
             [ 102000 ns] Test is running, debug_wb_pc = 0xbfc2776c
     ----[ 104845 ns] Number 8'd05 Functional Test Point PASS!!!
             [ 112000 ns] Test is running, debug_wb_pc = 0xbfc4a0ac
     ----[ 117885 ns] Number 8'd06 Functional Test Point PASS!!!
             [ 122000 ns] Test is running, debug_wb_pc = 0xbfc6a68c
             [ 132000 ns] Test is running, debug_wb_pc = 0xbfc6b62c
             [ 142000 ns] Test is running, debug_wb_pc = 0xbfc6c5cc
     ----[ 144265 ns] Number 8'd07 Functional Test Point PASS!!!
             [ 152000 ns] Test is running, debug_wb_pc = 0xbfc509e4
             [ 162000 ns] Test is running, debug_wb_pc = 0xbfc51984
     ----[ 167675 ns] Number 8'd08 Functional Test Point PASS!!!
             [ 172000 ns] Test is running, debug_wb_pc = 0xbfc03bb0
             [ 182000 ns] Test is running, debug_wb_pc = 0xbfc04b50
     ----[ 185575 ns] Number 8'd09 Functional Test Point PASS!!!
             [ 192000 ns] Test is running, debug_wb_pc = 0xbfc3e008
             [ 202000 ns] Test is running, debug_wb_pc = 0xbfc3efa8
     ----[ 203475 ns] Number 8'd10 Functional Test Point PASS!!!
             [ 212000 ns] Test is running, debug_wb_pc = 0xbfc6f800
             [ 222000 ns] Test is running, debug_wb_pc = 0xbfc707a0
     ----[ 222735 ns] Number 8'd11 Functional Test Point PASS!!!
             [ 232000 ns] Test is running, debug_wb_pc = 0xbfc02648
     ----[ 237365 ns] Number 8'd12 Functional Test Point PASS!!!
             [ 242000 ns] Test is running, debug_wb_pc = 0xbfc3faec
             [ 252000 ns] Test is running, debug_wb_pc = 0xbfc40f3c
     ----[ 261915 ns] Number 8'd13 Functional Test Point PASS!!!
             [ 262000 ns] Test is running, debug_wb_pc = 0xbfc00d58
             [ 272000 ns] Test is running, debug_wb_pc = 0xbfc64ab8
             [ 282000 ns] Test is running, debug_wb_pc = 0xbfc65db8
             [ 292000 ns] Test is running, debug_wb_pc = 0xbfc67094
     ----[ 296425 ns] Number 8'd14 Functional Test Point PASS!!!
             [ 302000 ns] Test is running, debug_wb_pc = 0xbfc84484
             [ 312000 ns] Test is running, debug_wb_pc = 0xbfc85814
             [ 322000 ns] Test is running, debug_wb_pc = 0xbfc86b8c
     ----[ 330855 ns] Number 8'd15 Functional Test Point PASS!!!
             [ 332000 ns] Test is running, debug_wb_pc = 0xbfc7a0f0
     ----[ 333825 ns] Number 8'd16 Functional Test Point PASS!!!
     ----[ 336795 ns] Number 8'd17 Functional Test Point PASS!!!
     ----[ 338455 ns] Number 8'd18 Functional Test Point PASS!!!
     ----[ 340625 ns] Number 8'd19 Functional Test Point PASS!!!
             [ 342000 ns] Test is running, debug_wb_pc = 0xbfc87f18
     ----[ 342805 ns] Number 8'd20 Functional Test Point PASS!!!
             [ 352000 ns] Test is running, debug_wb_pc = 0xbfc8006c
             [ 362000 ns] Test is running, debug_wb_pc = 0xbfc8100c
     ----[ 364615 ns] Number 8'd21 Functional Test Point PASS!!!
             [ 372000 ns] Test is running, debug_wb_pc = 0xbfc0b1c8
             [ 382000 ns] Test is running, debug_wb_pc = 0xbfc0c168
     ----[ 385015 ns] Number 8'd22 Functional Test Point PASS!!!
             [ 392000 ns] Test is running, debug_wb_pc = 0xbfc332a8
             [ 402000 ns] Test is running, debug_wb_pc = 0xbfc34248
     ----[ 406375 ns] Number 8'd23 Functional Test Point PASS!!!
             [ 412000 ns] Test is running, debug_wb_pc = 0xbfc61798
             [ 422000 ns] Test is running, debug_wb_pc = 0xbfc62738
             [ 432000 ns] Test is running, debug_wb_pc = 0xbfc636d8
     ----[ 432785 ns] Number 8'd24 Functional Test Point PASS!!!
             [ 442000 ns] Test is running, debug_wb_pc = 0xbfc7b564
             [ 452000 ns] Test is running, debug_wb_pc = 0xbfc7c504
     ----[ 456195 ns] Number 8'd25 Functional Test Point PASS!!!
             [ 462000 ns] Test is running, debug_wb_pc = 0xbfc4d470
             [ 472000 ns] Test is running, debug_wb_pc = 0xbfc4e410
     ----[ 481535 ns] Number 8'd26 Functional Test Point PASS!!!
             [ 482000 ns] Test is running, debug_wb_pc = 0xbfc6cfc8
             [ 492000 ns] Test is running, debug_wb_pc = 0xbfc6df68
     ----[ 499435 ns] Number 8'd27 Functional Test Point PASS!!!
             [ 502000 ns] Test is running, debug_wb_pc = 0xbfc8a360
             [ 512000 ns] Test is running, debug_wb_pc = 0xbfc8b300
             [ 522000 ns] Test is running, debug_wb_pc = 0xbfc8c2a0
     ----[ 525825 ns] Number 8'd28 Functional Test Point PASS!!!
             [ 532000 ns] Test is running, debug_wb_pc = 0xbfc78914
             [ 542000 ns] Test is running, debug_wb_pc = 0xbfc798b4
     ----[ 546225 ns] Number 8'd29 Functional Test Point PASS!!!
             [ 552000 ns] Test is running, debug_wb_pc = 0xbfc475a4
             [ 562000 ns] Test is running, debug_wb_pc = 0xbfc48544
             [ 572000 ns] Test is running, debug_wb_pc = 0xbfc494e4
     ----[ 572635 ns] Number 8'd30 Functional Test Point PASS!!!
             [ 582000 ns] Test is running, debug_wb_pc = 0xbfc09260
             [ 592000 ns] Test is running, debug_wb_pc = 0xbfc0a200
     ----[ 593035 ns] Number 8'd31 Functional Test Point PASS!!!
             [ 602000 ns] Test is running, debug_wb_pc = 0xbfc76b40
             [ 612000 ns] Test is running, debug_wb_pc = 0xbfc77ae0
     ----[ 615165 ns] Number 8'd32 Functional Test Point PASS!!!
             [ 622000 ns] Test is running, debug_wb_pc = 0xbfc42d9c
             [ 632000 ns] Test is running, debug_wb_pc = 0xbfc43d3c
     ----[ 634365 ns] Number 8'd33 Functional Test Point PASS!!!
             [ 642000 ns] Test is running, debug_wb_pc = 0xbfc0d4ac
             [ 652000 ns] Test is running, debug_wb_pc = 0xbfc0e44c
     ----[ 656735 ns] Number 8'd34 Functional Test Point PASS!!!
             [ 662000 ns] Test is running, debug_wb_pc = 0xbfc06b28
             [ 672000 ns] Test is running, debug_wb_pc = 0xbfc07ac8
     ----[ 676065 ns] Number 8'd35 Functional Test Point PASS!!!
             [ 682000 ns] Test is running, debug_wb_pc = 0xbfc5bc14
             [ 692000 ns] Test is running, debug_wb_pc = 0xbfc5cbb4
     ----[ 698445 ns] Number 8'd36 Functional Test Point PASS!!!
             [ 702000 ns] Test is running, debug_wb_pc = 0xbfc565fc
             [ 712000 ns] Test is running, debug_wb_pc = 0xbfc57bfc
             [ 722000 ns] Test is running, debug_wb_pc = 0xbfc59250
             [ 732000 ns] Test is running, debug_wb_pc = 0xbfc5a8d4
     ----[ 736645 ns] Number 8'd37 Functional Test Point PASS!!!
             [ 742000 ns] Test is running, debug_wb_pc = 0xbfc1eaec
             [ 752000 ns] Test is running, debug_wb_pc = 0xbfc20170
             [ 762000 ns] Test is running, debug_wb_pc = 0xbfc217e4
             [ 772000 ns] Test is running, debug_wb_pc = 0xbfc22e94
     ----[ 774605 ns] Number 8'd38 Functional Test Point PASS!!!
             [ 782000 ns] Test is running, debug_wb_pc = 0xbfc718dc
             [ 792000 ns] Test is running, debug_wb_pc = 0xbfc72f24
             [ 802000 ns] Test is running, debug_wb_pc = 0xbfc7456c
             [ 812000 ns] Test is running, debug_wb_pc = 0xbfc75be4
     ----[ 812805 ns] Number 8'd39 Functional Test Point PASS!!!
             [ 822000 ns] Test is running, debug_wb_pc = 0xbfc53414
             [ 832000 ns] Test is running, debug_wb_pc = 0xbfc548ec
             [ 842000 ns] Test is running, debug_wb_pc = 0xbfc55d4c
     ----[ 842485 ns] Number 8'd40 Functional Test Point PASS!!!
             [ 852000 ns] Test is running, debug_wb_pc = 0xbfc29d0c
             [ 862000 ns] Test is running, debug_wb_pc = 0xbfc2b0e0
             [ 872000 ns] Test is running, debug_wb_pc = 0xbfc2c480
             [ 882000 ns] Test is running, debug_wb_pc = 0xbfc2d884
     ----[ 886735 ns] Number 8'd41 Functional Test Point PASS!!!
             [ 892000 ns] Test is running, debug_wb_pc = 0xbfc18e80
             [ 902000 ns] Test is running, debug_wb_pc = 0xbfc1a2a0
             [ 912000 ns] Test is running, debug_wb_pc = 0xbfc1b658
             [ 922000 ns] Test is running, debug_wb_pc = 0xbfc1c9f4
             [ 932000 ns] Test is running, debug_wb_pc = 0xbfc1ddcc
     ----[ 933015 ns] Number 8'd42 Functional Test Point PASS!!!
             [ 942000 ns] Test is running, debug_wb_pc = 0xbfc121b8
             [ 952000 ns] Test is running, debug_wb_pc = 0xbfc13318
             [ 962000 ns] Test is running, debug_wb_pc = 0xbfc14478
             [ 972000 ns] Test is running, debug_wb_pc = 0xbfc155d8
             [ 982000 ns] Test is running, debug_wb_pc = 0xbfc16728
     ----[ 983765 ns] Number 8'd43 Functional Test Point PASS!!!
             [ 992000 ns] Test is running, debug_wb_pc = 0x00000000
             [1002000 ns] Test is running, debug_wb_pc = 0x00000000
             [1012000 ns] Test is running, debug_wb_pc = 0xbfc7e440
             [1022000 ns] Test is running, debug_wb_pc = 0x00000000
             [1032000 ns] Test is running, debug_wb_pc = 0xbfc7ed14
             [1042000 ns] Test is running, debug_wb_pc = 0x00000000
     ----[1043835 ns] Number 8'd44 Functional Test Point PASS!!!
             [1052000 ns] Test is running, debug_wb_pc = 0xbfc0ef50
             [1062000 ns] Test is running, debug_wb_pc = 0x00000000
             [1072000 ns] Test is running, debug_wb_pc = 0xbfc0f824
             [1082000 ns] Test is running, debug_wb_pc = 0x00000000
             [1092000 ns] Test is running, debug_wb_pc = 0x00000000
             [1102000 ns] Test is running, debug_wb_pc = 0x00000000
             [1112000 ns] Test is running, debug_wb_pc = 0x00000000
             [1122000 ns] Test is running, debug_wb_pc = 0xbfc10e7c
     ----[1131265 ns] Number 8'd45 Functional Test Point PASS!!!
             [1132000 ns] Test is running, debug_wb_pc = 0xbfc349e4
             [1142000 ns] Test is running, debug_wb_pc = 0xbfc35984
             [1152000 ns] Test is running, debug_wb_pc = 0xbfc36924
     ----[1154805 ns] Number 8'd46 Functional Test Point PASS!!!
             [1162000 ns] Test is running, debug_wb_pc = 0xbfc8240c
             [1172000 ns] Test is running, debug_wb_pc = 0xbfc833ac
     ----[1176105 ns] Number 8'd47 Functional Test Point PASS!!!
             [1182000 ns] Test is running, debug_wb_pc = 0xbfc88c94
     ----[1185635 ns] Number 8'd48 Functional Test Point PASS!!!
             [1192000 ns] Test is running, debug_wb_pc = 0xbfc17f80
     ----[1195145 ns] Number 8'd49 Functional Test Point PASS!!!
             [1202000 ns] Test is running, debug_wb_pc = 0xbfc60c04
     ----[1204035 ns] Number 8'd50 Functional Test Point PASS!!!
     ----[1209165 ns] Number 8'd51 Functional Test Point PASS!!!
             [1212000 ns] Test is running, debug_wb_pc = 0xbfc0337c
     ----[1215135 ns] Number 8'd52 Functional Test Point PASS!!!
     ----[1221745 ns] Number 8'd53 Functional Test Point PASS!!!
             [1222000 ns] Test is running, debug_wb_pc = 0xbfc00d94
     ----[1228035 ns] Number 8'd54 Functional Test Point PASS!!!
             [1232000 ns] Test is running, debug_wb_pc = 0x00000000
     ----[1234645 ns] Number 8'd55 Functional Test Point PASS!!!
     ----[1241885 ns] Number 8'd56 Functional Test Point PASS!!!
             [1242000 ns] Test is running, debug_wb_pc = 0xbfc00d60
     ----[1248485 ns] Number 8'd57 Functional Test Point PASS!!!
             [1252000 ns] Test is running, debug_wb_pc = 0xbfc4fa0c
     ----[1253335 ns] Number 8'd58 Functional Test Point PASS!!!
             [1262000 ns] Test is running, debug_wb_pc = 0xbfc37e08
             [1272000 ns] Test is running, debug_wb_pc = 0xbfc38d3c
     ----[1277255 ns] Number 8'd59 Functional Test Point PASS!!!
             [1282000 ns] Test is running, debug_wb_pc = 0xbfc67fc4
             [1292000 ns] Test is running, debug_wb_pc = 0xbfc68ee0
             [1302000 ns] Test is running, debug_wb_pc = 0xbfc69e00
     ----[1302835 ns] Number 8'd60 Functional Test Point PASS!!!
             [1312000 ns] Test is running, debug_wb_pc = 0xbfc2ef90
     ----[1321725 ns] Number 8'd61 Functional Test Point PASS!!!
             [1322000 ns] Test is running, debug_wb_pc = 0xbfc00ae8
             [1332000 ns] Test is running, debug_wb_pc = 0xbfc4b900
             [1342000 ns] Test is running, debug_wb_pc = 0xbfc4c7e8
     ----[1342985 ns] Number 8'd62 Functional Test Point PASS!!!
             [1352000 ns] Test is running, debug_wb_pc = 0xbfc44da4
             [1362000 ns] Test is running, debug_wb_pc = 0xbfc45cb4
     ----[1371175 ns] Number 8'd63 Functional Test Point PASS!!!
             [1372000 ns] Test is running, debug_wb_pc = 0xbfc2ff28
             [1382000 ns] Test is running, debug_wb_pc = 0xbfc30dd0
             [1392000 ns] Test is running, debug_wb_pc = 0xbfc31cf8
     ----[1397715 ns] Number 8'd64 Functional Test Point PASS!!!
             [1402000 ns] Test is running, debug_wb_pc = 0xbfc00400
     ----[1402325 ns] Number 8'd65 Functional Test Point PASS!!!
     ----[1407145 ns] Number 8'd66 Functional Test Point PASS!!!
             [1412000 ns] Test is running, debug_wb_pc = 0xbfc0068c
     ----[1412805 ns] Number 8'd67 Functional Test Point PASS!!!
     ----[1418375 ns] Number 8'd68 Functional Test Point PASS!!!
             [1422000 ns] Test is running, debug_wb_pc = 0x00000000
     ----[1424035 ns] Number 8'd69 Functional Test Point PASS!!!
     ----[1430385 ns] Number 8'd70 Functional Test Point PASS!!!
             [1432000 ns] Test is running, debug_wb_pc = 0xbfc00678
     ----[1436755 ns] Number 8'd71 Functional Test Point PASS!!!
             [1442000 ns] Test is running, debug_wb_pc = 0xbfc004c8
     ----[1443105 ns] Number 8'd72 Functional Test Point PASS!!!
     ----[1449745 ns] Number 8'd73 Functional Test Point PASS!!!
             [1452000 ns] Test is running, debug_wb_pc = 0x00000000
     ----[1456385 ns] Number 8'd74 Functional Test Point PASS!!!
             [1462000 ns] Test is running, debug_wb_pc = 0x00000000
     ----[1462895 ns] Number 8'd75 Functional Test Point PASS!!!
     ----[1468805 ns] Number 8'd76 Functional Test Point PASS!!!
             [1472000 ns] Test is running, debug_wb_pc = 0xbfc005ec
     ----[1476575 ns] Number 8'd77 Functional Test Point PASS!!!
             [1482000 ns] Test is running, debug_wb_pc = 0xbfc00384
     ----[1490295 ns] Number 8'd78 Functional Test Point PASS!!!
             [1492000 ns] Test is running, debug_wb_pc = 0xbfc0046c
             [1502000 ns] Test is running, debug_wb_pc = 0xbfc6cf10
     ----[1504015 ns] Number 8'd79 Functional Test Point PASS!!!
             [1512000 ns] Test is running, debug_wb_pc = 0x00000000
     ----[1517735 ns] Number 8'd80 Functional Test Point PASS!!!
             [1522000 ns] Test is running, debug_wb_pc = 0x00000000
     ----[1531455 ns] Number 8'd81 Functional Test Point PASS!!!
             [1532000 ns] Test is running, debug_wb_pc = 0xbfc003fc
             [1542000 ns] Test is running, debug_wb_pc = 0xbfc0038c
     ----[1545175 ns] Number 8'd82 Functional Test Point PASS!!!
             [1552000 ns] Test is running, debug_wb_pc = 0xbfc004dc
     ----[1558895 ns] Number 8'd83 Functional Test Point PASS!!!
             [1562000 ns] Test is running, debug_wb_pc = 0x00000000
             [1572000 ns] Test is running, debug_wb_pc = 0xbfc00380
     ----[1572625 ns] Number 8'd84 Functional Test Point PASS!!!
             [1582000 ns] Test is running, debug_wb_pc = 0xbfc0039c
     ----[1586365 ns] Number 8'd85 Functional Test Point PASS!!!
             [1592000 ns] Test is running, debug_wb_pc = 0xbfc00498
     ----[1600095 ns] Number 8'd86 Functional Test Point PASS!!!
             [1602000 ns] Test is running, debug_wb_pc = 0xbfc46a78
             [1612000 ns] Test is running, debug_wb_pc = 0xbfc003b8
     ----[1613825 ns] Number 8'd87 Functional Test Point PASS!!!
             [1622000 ns] Test is running, debug_wb_pc = 0xbfc00394
     ----[1627555 ns] Number 8'd88 Functional Test Point PASS!!!
             [1632000 ns] Test is running, debug_wb_pc = 0xbfc00484
     ----[1641285 ns] Number 8'd89 Functional Test Point PASS!!!
     ==============================================================
     Test end!
     ----PASS!!!
     $finish called at time : 1641885 ns : File "D:/practice_code/subject/hardware_design/soc_sram_func/testbench/mycpu_tb.v" Line 261
     run: Time (s): cpu = 00:00:32 ; elapsed = 00:00:29 . Memory (MB): peak = 1480.160 ; gain = 0.000
     
     ```



**axi连线加写直达cache测试**

1. **功能测试**

**![image-20210108014049504](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210108014049504.png)**

![image-20210108014223030](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210108014223030.png)

通过

2. **性能测试**

   实现效果：n4ddr 性能测试通过10个测试小程序。

   **Bitcount:**

   ![img](file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml76568\wps1.jpg) 

   **Bubble sort:**

   ![img](file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml76568\wps2.jpg) 

   **Coremark:**

   ![img](file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml76568\wps3.jpg) 

   **Crc32:**

   ![img](file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml76568\wps4.jpg) 

   **Dhrystone:**

   ![img](file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml76568\wps5.jpg)

   **quick sort :**

   ![img](file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml76568\wps6.jpg)

   **select sort:** 

   ![img](file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml76568\wps7.jpg)

   **sha:** 

   ![img](file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml76568\wps8.jpg)

   **stream:** 

   ![img](file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml76568\wps9.jpg)

   **string serach:** 

   ![img](file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml76568\wps10.jpg) 

    

**5** **参考设计说明**

1. mthi指令与mtlo指令的实现以及sll,srl,sra的准确译码参考《自己动手写CPU》.(雷思磊).pdf》的方法
2. mthi指令与mtlo指令的实现参考《自己动手写CPU》.(雷思磊).pdf》的方法
3. Hilo寄存器的实现也参考了《自己动手写CPU》.(雷思磊).pdf》
4. 可能产生溢出的指令add,addi,sub的溢出出现情况，slt,div,divu指令的实现参考《自己动手写CPU》.(雷思磊).pdf》的方法
5. mult指令参考给的PPT“ISA讲解_2020.pptx”。
6. 对于访存指令LB, LH, SB, SH, SW 这些读取或者存储数据不满足一个字的指令参考了《自己动手写cpu》，特别的，对于load相关指令如果其读取的数据不满足一个字的话，读的时候全部读出，只需要写的时候进行处理即可。
7. cpo_reg.v的实现参考学长发的参考代码“ref_code/cp0_reg”。
8. mmu.v的映射参考学长发的ppt“2020/硬综讲解1”。
9. "自己动手写CPU/自己动手写CPU光盘资源.rar"
10. **[ MIPS-CPU-implementation](https://github.com/Hanmengnan/MIPS-CPU-implementation)**
11. 硬件综合设计资料_full_v0.1.zip
12. [cqu设计要求以及文档地址gitee](https://gitee.com/yuanfuyan/CO-lab-material-CQU)
13. sram接口，axi接口，sram接口转类sram接口都是参考学长给出的源码。
14. cache模块参考计算机体系接口实验二。

**6** **总结**

​	**至此，历时三周，我们小组尽力完成2020年寒假小学期2018级硬件综合设计所布置的任务，共同合作，一起解决问题，写出了这个简单的cpu。**

**7 参考文献**

[1]雷思磊. 自己动手写 *CPU*. 电子工业出版社, 2014

[2]“系统能力培养大赛”MIPS指令系统规范_v1.01

